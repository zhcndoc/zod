---
title: å®šä¹‰æ¨¡å¼
description: "æ‰€æœ‰ Zod æ¨¡å¼ç±»å‹ã€æ–¹æ³•å’ŒéªŒè¯åŠŸèƒ½çš„å®Œæ•´ API å‚è€ƒ"
---

import { Tabs, Tab } from 'fumadocs-ui/components/tabs';
import { Callout } from "fumadocs-ui/components/callout"
import { Accordion, Accordions } from 'fumadocs-ui/components/accordion';

è¦éªŒè¯æ•°æ®ï¼Œæ‚¨å¿…é¡»é¦–å…ˆå®šä¹‰ä¸€ä¸ª*æ¨¡å¼*ã€‚æ¨¡å¼ä»£è¡¨*ç±»å‹*ï¼Œä»ç®€å•çš„åŸå§‹å€¼åˆ°å¤æ‚çš„åµŒå¥—å¯¹è±¡å’Œæ•°ç»„ã€‚

## åŸå§‹ç±»å‹

```ts
import * as z from "zod";

// åŸå§‹ç±»å‹
z.string();
z.number();
z.bigint();
z.boolean();
z.symbol();
z.undefined();
z.null();
```


### å¼ºåˆ¶è½¬æ¢

è‹¥è¦å°†è¾“å…¥æ•°æ®å¼ºåˆ¶è½¬æ¢ä¸ºé€‚å½“çš„ç±»å‹ï¼Œè¯·æ”¹ç”¨ `z.coerce`ï¼š

```ts
z.coerce.string();    // String(input)
z.coerce.number();    // Number(input)
z.coerce.boolean();   // Boolean(input)
z.coerce.bigint();    // BigInt(input)
```

è¿™äº›æ¨¡å¼çš„å¼ºåˆ¶è½¬æ¢ç‰ˆæœ¬å°è¯•å°†è¾“å…¥å€¼è½¬æ¢ä¸ºé€‚åˆçš„ç±»å‹ã€‚

```ts
const schema = z.coerce.string();

schema.parse("tuna");    // => "tuna"
schema.parse(42);        // => "42"
schema.parse(true);      // => "true"
schema.parse(null);      // => "null"
```

è¿™äº›å¼ºåˆ¶è½¬æ¢æ¨¡å¼çš„è¾“å…¥ç±»å‹é»˜è®¤ä¸º `unknown`ã€‚è¦æŒ‡å®šæ›´å…·ä½“çš„è¾“å…¥ç±»å‹ï¼Œè¯·ä¼ é€’æ³›å‹å‚æ•°ï¼š

```ts
const A = z.coerce.number();
type AInput = z.input<typeof A>; // => unknown

const B = z.coerce.number<number>();
type BInput = z.input<typeof B>; // => number
```

<Accordions type="single">
<Accordion title="Zod ä¸­çš„å¼ºåˆ¶è½¬æ¢åŸç†">
  
  Zod ä½¿ç”¨å†…ç½®æ„é€ å‡½æ•°å¯¹æ‰€æœ‰è¾“å…¥æ‰§è¡Œå¼ºåˆ¶è½¬æ¢ã€‚

  | Zod API                  | å¼ºåˆ¶è½¬æ¢                   |
  |--------------------------|----------------------------|
  | `z.coerce.string()`      | `String(value)`            |
  | `z.coerce.number()`      | `Number(value)`            |
  | `z.coerce.boolean()`     | `Boolean(value)`           |
  | `z.coerce.bigint()`      | `BigInt(value)`            |
  | `z.coerce.date()`        | `new Date(value)`          |

  ä½¿ç”¨ `z.coerce.boolean()` è¿›è¡Œå¸ƒå°”å¼ºåˆ¶è½¬æ¢å¯èƒ½ä¸ä¼šåƒæ‚¨é¢„æœŸçš„é‚£æ ·å·¥ä½œã€‚ä»»ä½•[çœŸå€¼](https://developer.mozilla.org/en-US/docs/Glossary/Truthy)éƒ½è¢«å¼ºåˆ¶è½¬æ¢ä¸º `true`ï¼Œè€Œä»»ä½•[å‡å€¼](https://developer.mozilla.org/en-US/docs/Glossary/Falsy)éƒ½è¢«å¼ºåˆ¶è½¬æ¢ä¸º `false`ã€‚

  ```ts
  const schema = z.coerce.boolean(); // Boolean(input)

  schema.parse("tuna"); // => true
  schema.parse("true"); // => true
  schema.parse("false"); // => true
  schema.parse(1); // => true
  schema.parse([]); // => true

  schema.parse(0); // => false
  schema.parse(""); // => false
  schema.parse(undefined); // => false
  schema.parse(null); // => false
  ```

  è¦å®Œå…¨æ§åˆ¶å¼ºåˆ¶é€»è¾‘ï¼Œè¯·è€ƒè™‘ä½¿ç”¨ [`z.transform()`](#transforms) æˆ– [`z.pipe()`](#pipes)ã€‚

</Accordion>
<Accordion title="Customizing the input type">
  
  é»˜è®¤æƒ…å†µä¸‹ï¼Œä»»ä½• `z.coerce` æ¨¡å¼çš„ _input_ ç±»å‹ä¸º `unknown`ã€‚åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œè¾“å…¥ç±»å‹å¯èƒ½æ›´å…·ä½“ä¼šæ›´å¥½ã€‚æ‚¨å¯ä»¥é€šè¿‡æ³›å‹å‚æ•°æŒ‡å®šè¾“å…¥ç±»å‹ã€‚

  ```ts
  const regularCoerce = z.coerce.string();
  type RegularInput = z.input<typeof regularCoerce>; // => unknown
  type RegularOutput = z.output<typeof regularCoerce>; // => string

  const customInput = z.coerce.string<string>();
  type CustomInput = z.input<typeof customInput>; // => string
  type CustomOutput = z.output<typeof customInput>; // => string
  ```

</Accordion>
</Accordions>



## å­—é¢é‡

å­—é¢é‡æ¨¡å¼è¡¨ç¤ºä¸€ç§ [å­—é¢é‡ç±»å‹](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types)ï¼Œä¾‹å¦‚ `"hello world"` æˆ– `5`ã€‚

```ts
const tuna = z.literal("tuna");
const twelve = z.literal(12);
const twobig = z.literal(2n);
const tru = z.literal(true);
```

è¡¨ç¤º JavaScript å­—é¢é‡ `null` å’Œ `undefined`ï¼š

```ts
z.null();
z.undefined();
z.void(); // ç­‰ä»·äº z.undefined()
```

å…è®¸å¤šä¸ªå­—é¢é‡å€¼ï¼š

```ts
const colors = z.literal(["red", "green", "blue"]);

colors.parse("green"); // âœ…
colors.parse("yellow"); // âŒ
```

ä»å­—é¢é‡æ¨¡å¼ä¸­æå–å…è®¸å€¼é›†åˆï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
colors.values; // => Set<"red" | "green" | "blue">
```
</Tab>
<Tab value="Zod Mini">
```ts
// æ— å¯¹åº”åŠŸèƒ½
```
</Tab>
</Tabs>



## å­—ç¬¦ä¸²

{/* Zod æä¾›äº†è‹¥å¹²å†…ç½®çš„å­—ç¬¦ä¸²éªŒè¯å’Œè½¬æ¢ APIã€‚

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
z.string().startsWith("fourscore")
```
</Tab>
<Tab value="Zod Mini">
```ts
z.string().check(z.startsWith("fourscore"))
```
</Tab>
</Tabs>

ä»¥ä¸‹æ‰€æœ‰ API å‡æ”¯æŒ `error` å‚æ•°æ¥è‡ªå®šä¹‰é”™è¯¯æ¶ˆæ¯ã€‚

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
z.string().startsWith("fourscore", {error: "Nice try, buddy"})
```
</Tab>
<Tab value="Zod Mini">
```ts
z.string().check(z.startsWith("fourscore", {error: "Nice try, buddy"}))
```
</Tab></Tabs> */}


Zod æä¾›äº†ä¸€äº›å†…ç½®çš„å­—ç¬¦ä¸²éªŒè¯å’Œè½¬æ¢ APIã€‚æ‰§è¡Œå¸¸è§å­—ç¬¦ä¸²éªŒè¯ï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
z.string().max(5);
z.string().min(5);
z.string().length(5);
z.string().regex(/^[a-z]+$/);
z.string().startsWith("aaa");
z.string().endsWith("zzz");
z.string().includes("---");
z.string().uppercase();
z.string().lowercase();
```
</Tab>
<Tab value="Zod Mini">
```ts
z.string().check(z.maxLength(5));
z.string().check(z.minLength(5));
z.string().check(z.length(5));
z.string().check(z.regex(/^[a-z]+$/));
z.string().check(z.startsWith("aaa"));
z.string().check(z.endsWith("zzz"));
z.string().check(z.includes("---"));
z.string().check(z.uppercase());
z.string().check(z.lowercase());
```
</Tab>
</Tabs>

æ‰§è¡Œç®€å•çš„å­—ç¬¦ä¸²è½¬æ¢ï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
z.string().trim(); // å»é™¤ç©ºç™½
z.string().toLowerCase(); // è½¬å°å†™
z.string().toUpperCase(); // è½¬å¤§å†™
z.string().normalize(); // è§„èŒƒåŒ– Unicode å­—ç¬¦
```
</Tab>
<Tab value="Zod Mini">
```ts
z.string().check(z.trim()); // å»é™¤ç©ºç™½
z.string().check(z.toLowerCase()); // è½¬å°å†™
z.string().check(z.toUpperCase()); // è½¬å¤§å†™
z.string().check(z.normalize()); // è§„èŒƒåŒ– Unicode å­—ç¬¦
```
</Tab>
</Tabs>

## å­—ç¬¦ä¸²æ ¼å¼

éªŒè¯å¸¸è§å­—ç¬¦ä¸²æ ¼å¼ï¼š

```ts
z.email();
z.uuid();
z.url();
z.httpUrl();       // http or https URLs only
z.hostname();
z.emoji();         // éªŒè¯å•ä¸ª emoji å­—ç¬¦
z.base64();
z.base64url();
z.hex();
z.jwt();
z.nanoid();
z.cuid();
z.cuid2();
z.ulid();
z.ipv4();
z.ipv6();
z.mac();
z.cidrv4();        // ipv4 CIDR block
z.cidrv6();        // ipv6 CIDR block
z.hash("sha256");  // or "sha1", "sha384", "sha512", "md5"
z.iso.date();
z.iso.time();
z.iso.datetime();
z.iso.duration();
```

### é‚®ä»¶

éªŒè¯é‚®ç®±åœ°å€ï¼š

```ts
z.email();
```

é»˜è®¤æƒ…å†µä¸‹ï¼ŒZod ä½¿ç”¨ä¸€ç§ç›¸å¯¹ä¸¥æ ¼çš„é‚®ç®±æ­£åˆ™è¡¨è¾¾å¼ï¼Œè®¾è®¡ç”¨æ¥éªŒè¯åŒ…å«å¸¸è§å­—ç¬¦çš„æ™®é€šé‚®ç®±åœ°å€ã€‚å¤§è‡´ç›¸å½“äº Gmail é‡‡ç”¨çš„è§„åˆ™ã€‚æ¬²äº†è§£æ›´å¤šï¼Œå‚è€ƒ[è¿™ç¯‡æ–‡ç« ](https://colinhacks.com/essays/reasonable-email-regex)ã€‚

```ts
/^(?!\.)(?!.*\.\.)([a-z0-9_'+\-\.]*)[a-z0-9_+-]@([a-z0-9][a-z0-9\-]*\.)+[a-z]{2,}$/i
```

è¦è‡ªå®šä¹‰é‚®ç®±éªŒè¯è¡Œä¸ºï¼Œå¯ä»¥å‘ `pattern` å‚æ•°ä¼ é€’ä¸€ä¸ªè‡ªå®šä¹‰æ­£åˆ™è¡¨è¾¾å¼ã€‚

```ts
z.email({ pattern: /your regex here/ });
```

Zod å¯¼å‡ºäº†ä¸€äº›å®ç”¨çš„æ­£åˆ™è¡¨è¾¾å¼å¯ä¾›ä½¿ç”¨ã€‚

```ts
// Zod é»˜è®¤é‚®ç®±æ­£åˆ™
z.email();
z.email({ pattern: z.regexes.email }); // ç­‰ä»·

// æµè§ˆå™¨ç”¨äº input[type=email] å­—æ®µçš„æ­£åˆ™
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/email
z.email({ pattern: z.regexes.html5Email });

// ç»å…¸ emailregex.com æ­£åˆ™ (RFC 5322)
z.email({ pattern: z.regexes.rfc5322Email });

// ä¸€ä¸ªå…è®¸ Unicode çš„å®½æ¾æ­£åˆ™ (é€‚ç”¨äºå›½é™…é‚®ç®±)
z.email({ pattern: z.regexes.unicodeEmail });
```

### UUID

éªŒè¯ UUIDï¼š

```ts
z.uuid();
```

æŒ‡å®šç‰¹å®š UUID ç‰ˆæœ¬ï¼š

```ts
// æ”¯æŒ "v1", "v2", "v3", "v4", "v5", "v6", "v7", "v8"
z.uuid({ version: "v4" });

// æ–¹ä¾¿å½¢å¼
z.uuidv4();
z.uuidv6();
z.uuidv7();
```

The RFC 9562/4122 UUID spec requires the first two bits of byte 8 to be `10`. Other UUID-like identifiers do not enforce this constraint. To validate any UUID-like identifier:

```ts
z.guid();
```

### URL

éªŒè¯ä»»æ„ WHATWG å…¼å®¹ URLï¼š

```ts
const schema = z.url();

schema.parse("https://example.com"); // âœ…
schema.parse("http://localhost"); // âœ…
schema.parse("mailto:noreply@zod.dev"); // âœ…
```

å¦‚æ‚¨æ‰€è§ï¼Œè¿™éå¸¸å®½æ¾ã€‚å†…éƒ¨ä½¿ç”¨ `new URL()` æ„é€ å‡½æ•°éªŒè¯è¾“å…¥ï¼›æ­¤è¡Œä¸ºå¯èƒ½å› å¹³å°å’Œè¿è¡Œæ—¶è€Œå¼‚ï¼Œä½†è¿™æ˜¯åœ¨ä»»ä½• JS è¿è¡Œæ—¶/å¼•æ“ä¸ŠéªŒè¯ URI/URL çš„æœ€ä¸¥è°¨æ–¹æ³•ã€‚

éªŒè¯ä¸»æœºåæ˜¯å¦åŒ¹é…ç‰¹å®šæ­£åˆ™ï¼š

```ts
const schema = z.url({ hostname: /^example\.com$/ });

schema.parse("https://example.com"); // âœ…
schema.parse("https://zombo.com"); // âŒ
```

è¦éªŒè¯åè®®æ˜¯å¦åŒ¹é…ç‰¹å®šæ­£åˆ™ï¼Œä½¿ç”¨ `protocol` å‚æ•°ã€‚

```ts
const schema = z.url({ protocol: /^https$/ });

schema.parse("https://example.com"); // âœ…
schema.parse("http://example.com"); // âŒ
```

<Callout>
  **Web URLs** â€” è®¸å¤šæƒ…å†µä¸‹ï¼Œæ‚¨å¯èƒ½åªæƒ³éªŒè¯ Web URLã€‚æ¨èçš„æ¨¡å¼å¦‚ä¸‹ï¼š

  ```ts
  const httpUrl = z.url({
    protocol: /^https?$/,
    hostname: z.regexes.domain
  });
  ```

  è¯¥é…ç½®é™å®šåè®®ä¸º `http`/`https`ï¼Œå¹¶é€šè¿‡ `z.regexes.domain` æ­£åˆ™ç¡®ä¿ä¸»æœºåä¸ºåˆæ³•åŸŸåï¼š

  ```ts
  /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/
  ```
</Callout>

è¦è§„èŒƒåŒ– URLï¼Œè¯·ä½¿ç”¨ `normalize` æ ‡å¿—ã€‚è¿™å°†ç”¨ `new URL()` è¿”å›çš„ [è§„èŒƒåŒ– URL](https://chatgpt.com/share/6881547f-bebc-800f-9093-f5981e277c2c) è¦†ç›–è¾“å…¥å€¼ã€‚

```ts
new URL("HTTP://ExAmPle.com:80/./a/../b?X=1#f oo").href
// => "http://example.com/b?X=1#f%20oo"
```

### ISO æ—¥æœŸæ—¶é—´

æ­£å¦‚æ‚¨å¯èƒ½æ³¨æ„åˆ°çš„ï¼ŒZod å­—ç¬¦ä¸²åŒ…å«äº†ä¸€äº›ä¸æ—¥æœŸ/æ—¶é—´ç›¸å…³çš„éªŒè¯ã€‚è¿™äº›éªŒè¯æ˜¯åŸºäºæ­£åˆ™è¡¨è¾¾å¼çš„ï¼Œå› æ­¤å®ƒä»¬æ²¡æœ‰å®Œæ•´çš„æ—¥æœŸ/æ—¶é—´åº“é‚£ä¹ˆä¸¥æ ¼ã€‚ç„¶è€Œï¼Œå®ƒä»¬å¯¹äºéªŒè¯ç”¨æˆ·è¾“å…¥éå¸¸æ–¹ä¾¿ã€‚

`z.iso.datetime()` æ–¹æ³•å¼ºåˆ¶æ‰§è¡Œ ISO 8601ï¼›é»˜è®¤æƒ…å†µä¸‹ï¼Œä¸å…è®¸æ—¶åŒºåç§»ï¼š

```ts
const datetime = z.iso.datetime();

datetime.parse("2020-01-01T06:15:00Z"); // âœ…
datetime.parse("2020-01-01T06:15:00.123Z"); // âœ…
datetime.parse("2020-01-01T06:15:00.123456Z"); // âœ… (arbitrary precision)
datetime.parse("2020-01-01T06:15:00+02:00"); // âŒ (offsets not allowed)
datetime.parse("2020-01-01T06:15:00"); // âŒ (local not allowed)
```

å…è®¸æ—¶åŒºåç§»ï¼š

```ts
const datetime = z.iso.datetime({ offset: true });

// allows timezone offsets
datetime.parse("2020-01-01T06:15:00+02:00"); // âœ…

// basic offsets not allowed
datetime.parse("2020-01-01T06:15:00+02");    // âŒ
datetime.parse("2020-01-01T06:15:00+0200");  // âŒ

// Z is still supported
datetime.parse("2020-01-01T06:15:00Z"); // âœ… 
```

å…è®¸æ— æ—¶åŒºï¼ˆæœ¬åœ°ï¼‰æ—¥æœŸæ—¶é—´ï¼š

```ts
const schema = z.iso.datetime({ local: true });
schema.parse("2020-01-01T06:15:01"); // âœ…
schema.parse("2020-01-01T06:15"); // âœ… seconds optional
```

é™åˆ¶å…è®¸çš„æ—¶é—´ `precision`ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œç§’æ•°ä¸ºå¯é€‰ä¸”å…è®¸ä»»æ„äºšç§’çº§ç²¾åº¦ã€‚

```ts
const a = z.iso.datetime();
a.parse("2020-01-01T06:15Z"); // âœ…
a.parse("2020-01-01T06:15:00Z"); // âœ…
a.parse("2020-01-01T06:15:00.123Z"); // âœ…

const b = z.iso.datetime({ precision: -1 }); // minute precision (no seconds)
b.parse("2020-01-01T06:15Z"); // âœ…
b.parse("2020-01-01T06:15:00Z"); // âŒ
b.parse("2020-01-01T06:15:00.123Z"); // âŒ

const c = z.iso.datetime({ precision: 0 }); // second precision only
c.parse("2020-01-01T06:15Z"); // âŒ
c.parse("2020-01-01T06:15:00Z"); // âœ…
c.parse("2020-01-01T06:15:00.123Z"); // âŒ

const d = z.iso.datetime({ precision: 3 }); // millisecond precision only
d.parse("2020-01-01T06:15Z"); // âŒ
d.parse("2020-01-01T06:15:00Z"); // âŒ
d.parse("2020-01-01T06:15:00.123Z"); // âœ…
```

### ISO æ—¥æœŸ

`z.iso.date()` æ–¹æ³•éªŒè¯æ ¼å¼ä¸º `YYYY-MM-DD` çš„å­—ç¬¦ä¸²ã€‚

```ts
const date = z.iso.date();

date.parse("2020-01-01"); // âœ…
date.parse("2020-1-1"); // âŒ
date.parse("2020-01-32"); // âŒ
```

### ISO æ—¶é—´

`z.iso.time()` æ–¹æ³•ç”¨äºéªŒè¯æ ¼å¼ä¸º `HH:MM[:SS[.s+]]` çš„å­—ç¬¦ä¸²ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œç§’æ˜¯å¯é€‰çš„ï¼Œå­ç§’å°æ•°ä¹Ÿæ˜¯å¯é€‰çš„ã€‚

```ts
const time = z.iso.time();

time.parse("03:15"); // âœ…
time.parse("03:15:00"); // âœ…
time.parse("03:15:00.9999999"); // âœ… (arbitrary precision)
```

ä¸å…è®¸ä»»ä½•å½¢å¼çš„æŠµæ¶ˆã€‚

```ts
time.parse("03:15:00Z"); // âŒ (no `Z` allowed)
time.parse("03:15:00+02:00"); // âŒ (no offsets allowed)
```

ä½¿ç”¨ `precision` å‚æ•°æ¥é™åˆ¶å…è®¸çš„å°æ•°ç²¾åº¦ã€‚

```ts
z.iso.time({ precision: -1 }); // HH:MM (minute precision)
z.iso.time({ precision: 0 });  // HH:MM:SS (second precision)
z.iso.time({ precision: 1 });  // HH:MM:SS.s (decisecond precision)
z.iso.time({ precision: 2 });  // HH:MM:SS.ss (centisecond precision)
z.iso.time({ precision: 3 });  // HH:MM:SS.sss (millisecond precision)
```

### IP åœ°å€

```ts
const ipv4 = z.ipv4();
ipv4.parse("192.168.0.0"); // âœ…

const ipv6 = z.ipv6();
ipv6.parse("2001:db8:85a3::8a2e:370:7334"); // âœ…
```

### IP å— (CIDR)

éªŒè¯ä½¿ç”¨[CIDR è¡¨ç¤ºæ³•](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)çš„ IP åœ°å€æ®µã€‚

```ts
const cidrv4 = z.cidrv4();
cidrv4.parse("192.168.0.0/24"); // âœ…

const cidrv6 = z.cidrv6();
cidrv6.parse("2001:db8::/32"); // âœ…
```

### MAC Addresses

Validate standard 48-bit MAC address [IEEE 802](https://en.wikipedia.org/wiki/MAC_address).

```ts
const mac = z.mac(); 
mac.parse("00:1A:2B:3C:4D:5E");  // âœ…
mac.parse("00-1a-2b-3c-4d-5e");  // âŒ colon-delimited by default
mac.parse("001A:2B3C:4D5E");     // âŒ standard formats only
mac.parse("00:1A:2b:3C:4d:5E");  // âŒ no mixed case

// custom delimiter
const dashMac = z.mac({ delimiter: "-" });
dashMac.parse("00-1A-2B-3C-4D-5E"); // âœ…
```

### JWTs

éªŒè¯ [JSON Web Tokens](https://jwt.io/)ã€‚

```ts
z.jwt();
z.jwt({ alg: "HS256" });
```

### å“ˆå¸Œ

éªŒè¯åŠ å¯†å“ˆå¸Œå€¼ï¼š

```ts
z.hash("md5");
z.hash("sha1");
z.hash("sha256");
z.hash("sha384");
z.hash("sha512");
```

é»˜è®¤æƒ…å†µä¸‹ï¼Œ`z.hash()` æœŸæœ›åå…­è¿›åˆ¶ç¼–ç ï¼Œè¿™æ˜¯å¸¸è§„åšæ³•ã€‚æ‚¨å¯ä»¥ä½¿ç”¨ `enc` å‚æ•°æŒ‡å®šä¸åŒçš„ç¼–ç ï¼š

```ts
z.hash("sha256", { enc: "hex" });       // default
z.hash("sha256", { enc: "base64" });    // base64 encoding
z.hash("sha256", { enc: "base64url" }); // base64url encoding (no padding)
```

<Accordions>
<Accordion title="Expected lengths and padding">

| Algorithm / Encoding | `"hex"`  | `"base64"`  | `"base64url"`  |
|-----------|-----------|--------------|-----------------|
| `"md5"`   | 32        | 24 (22 + "==") | 22              |
| `"sha1"`  | 40        | 28 (27 + "=")  | 27              |
| `"sha256"`| 64        | 44 (43 + "=")  | 43              |
| `"sha384"`| 96        | 64 (no padding)| 64              |
| `"sha512"`| 128       | 88 (86 + "==") | 86              |

</Accordion>
</Accordions>

### è‡ªå®šä¹‰æ ¼å¼

è¦å®šä¹‰æ‚¨è‡ªå·±çš„å­—ç¬¦ä¸²æ ¼å¼ï¼š

```ts
const coolId = z.stringFormat("cool-id", ()=>{
  // arbitrary validation here
  return val.length === 100 && val.startsWith("cool-");
});

// a regex is also accepted
z.stringFormat("cool-id", /^cool-[a-z0-9]{95}$/);
```

æ­¤æ¨¡å¼å°†äº§ç”Ÿ `"invalid_format"` é—®é¢˜ï¼Œè¿™äº›é—®é¢˜æ¯”é€šè¿‡ç»†åŒ–æˆ– `z.custom()` äº§ç”Ÿçš„ `"custom"` é”™è¯¯æ›´å…·æè¿°æ€§ã€‚

```ts
myFormat.parse("invalid input!");
// ZodError: [
//   {
//     "code": "invalid_format",
//     "format": "cool-id",
//     "path": [],
//     "message": "Invalid cool-id"
//   }
// ]
```

## æ¨¡æ¿å­—é¢é‡

> **æ–°** â€” åœ¨ `zod@4.0` ä¸­å¼•å…¥ã€‚

å®šä¹‰æ¨¡æ¿å­—é¢é‡æ¨¡å¼ï¼š

```ts
const schema = z.templateLiteral([ "hello, ", z.string(), "!" ]);
// `hello, ${string}!`
```

`z.templateLiteral` API å¯ä»¥å¤„ç†ä»»æ„æ•°é‡çš„å­—ç¬¦ä¸²å­—é¢é‡ï¼ˆå¦‚ `"hello"`ï¼‰å’Œæ¨¡å¼ã€‚å¯ä¼ å…¥ä»»ä½•æ¨æ–­ç±»å‹å¯èµ‹å€¼ç»™`string | number | bigint | boolean | null | undefined`çš„æ¨¡å¼ã€‚

```ts
z.templateLiteral([ "hi there" ]);
// `hi there`

z.templateLiteral([ "email: ", z.string() ]);
// `email: ${string}`

z.templateLiteral([ "high", z.literal(5) ]);
// `high5`

z.templateLiteral([ z.nullable(z.literal("grassy")) ]);
// `grassy` | `null`

z.templateLiteral([ z.number(), z.enum(["px", "em", "rem"]) ]);
// `${number}px` | `${number}em` | `${number}rem`
```

## æ•°å­—

ä½¿ç”¨ `z.number()` éªŒè¯æ•°å­—ã€‚å…è®¸æ‰€æœ‰æœ‰é™æ•°å­—ã€‚

```ts
const schema = z.number();

schema.parse(3.14);      // âœ…
schema.parse(NaN);       // âŒ
schema.parse(Infinity);  // âŒ
```

Zod å®ç°äº†è‹¥å¹²ç‰¹å®šæ•°å­—çš„éªŒè¯ï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
z.number().gt(5);
z.number().gte(5);                     // åŒ .min(5)
z.number().lt(5);
z.number().lte(5);                     // åŒ .max(5)
z.number().positive();       
z.number().nonnegative();    
z.number().negative(); 
z.number().nonpositive(); 
z.number().multipleOf(5);              // åŒ .step(5)
```
</Tab>
<Tab value="Zod Mini">
```ts
z.number().check(z.gt(5));
z.number().check(z.gte(5));            // åŒ .minimum(5)
z.number().check(z.lt(5));
z.number().check(z.lte(5));            // åŒ .maximum(5)
z.number().check(z.positive()); 
z.number().check(z.nonnegative()); 
z.number().check(z.negative()); 
z.number().check(z.nonpositive()); 
z.number().check(z.multipleOf(5));     // åŒ .step(5)
```
</Tab>
</Tabs>

å¦‚æœï¼ˆå› æŸäº›åŸå› ï¼‰æƒ³éªŒè¯ `NaN`ï¼Œä½¿ç”¨ `z.nan()`ã€‚

```ts
z.nan().parse(NaN);              // âœ…
z.nan().parse("anything else");  // âŒ
```

## æ•´æ•°

éªŒè¯æ•´æ•°ï¼š

```ts
z.int();     // é™åˆ¶åœ¨å®‰å…¨æ•´æ•°èŒƒå›´
z.int32();   // é™åˆ¶åœ¨ int32 èŒƒå›´
```

## BigInt

éªŒè¯ BigIntsï¼š

```ts
z.bigint();
```

Zod æä¾›äº†ä¸€äº›é’ˆå¯¹ bigint çš„éªŒè¯ã€‚

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
z.bigint().gt(5n);
z.bigint().gte(5n);                    // åŒ `.min(5n)`
z.bigint().lt(5n);
z.bigint().lte(5n);                    // åŒ `.max(5n)`
z.bigint().positive(); 
z.bigint().nonnegative(); 
z.bigint().negative(); 
z.bigint().nonpositive(); 
z.bigint().multipleOf(5n);             // åŒ `.step(5n)`
```
</Tab>
<Tab value="Zod Mini">
```ts
z.bigint().check(z.gt(5n));
z.bigint().check(z.gte(5n));           // åŒ `.minimum(5n)`
z.bigint().check(z.lt(5n));
z.bigint().check(z.lte(5n));           // åŒ `.maximum(5n)`
z.bigint().check(z.positive()); 
z.bigint().check(z.nonnegative()); 
z.bigint().check(z.negative()); 
z.bigint().check(z.nonpositive()); 
z.bigint().check(z.multipleOf(5n));    // åŒ `.step(5n)`
```

</Tab>
</Tabs>

## å¸ƒå°”å€¼

éªŒè¯å¸ƒå°”å€¼ï¼š

```ts
z.boolean().parse(true); // => true
z.boolean().parse(false); // => false
```

## æ—¥æœŸ

ä½¿ç”¨ `z.date()` éªŒè¯ `Date` å®ä¾‹ã€‚

```ts
z.date().safeParse(new Date()); // success: true
z.date().safeParse("2022-01-12T06:15:00.000Z"); // success: false
```

è‡ªå®šä¹‰é”™è¯¯æ¶ˆæ¯ï¼š

```ts
z.date({
  error: issue => issue.input === undefined ? "Required" : "Invalid date"
});
```

Zod æä¾›äº†ä¸€äº›é’ˆå¯¹æ—¥æœŸçš„éªŒè¯ã€‚

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
z.date().min(new Date("1900-01-01"), { error: "Too old!" });
z.date().max(new Date(), { error: "Too young!" });
```
</Tab>
<Tab value="Zod Mini">
```ts
z.date().check(z.minimum(new Date("1900-01-01"), { error: "Too old!" }));
z.date().check(z.maximum(new Date(), { error: "Too young!" }));
```
</Tab>
</Tabs>

<div id="zod-enums" style={{height:"0px" }} /> 

## æšä¸¾

ä½¿ç”¨ `z.enum` éªŒè¯è¾“å…¥æ˜¯å¦å±äºå›ºå®šçš„å…è®¸å­—ç¬¦ä¸²é›†åˆã€‚

```ts
const FishEnum = z.enum(["Salmon", "Tuna", "Trout"]);

FishEnum.parse("Salmon"); // => "Salmon"
FishEnum.parse("Swordfish"); // => âŒ
```

<Callout>
  æ³¨æ„ â€” å¦‚æœå°†å­—ç¬¦ä¸²æ•°ç»„å®šä¹‰ä¸ºå˜é‡ï¼ŒZod å°†æ— æ³•æ­£ç¡®æ¨æ–­å„å…ƒç´ çš„ç²¾ç¡®å€¼ã€‚

  ```ts
  const fish = ["Salmon", "Tuna", "Trout"];
  
  const FishEnum = z.enum(fish);
  type FishEnum = z.infer<typeof FishEnum>; // string
  ```

  è§£å†³æ–¹æ³•æ˜¯ï¼Œå§‹ç»ˆç›´æ¥å°†æ•°ç»„ä¼ å…¥ `z.enum()`ï¼Œæˆ–ä½¿ç”¨ [`as const`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions)ã€‚

  ```ts
  const fish = ["Salmon", "Tuna", "Trout"] as const;

  const FishEnum = z.enum(fish);
  type FishEnum = z.infer<typeof FishEnum>; // "Salmon" | "Tuna" | "Trout"
  ```
</Callout>

æ”¯æŒç±»ä¼¼æšä¸¾çš„å¯¹è±¡å­—é¢é‡ `{ [key: string]: string | number }`ã€‚ 

```ts
const Fish = {
  Salmon: 0,
  Tuna: 1
} as const

const FishEnum = z.enum(Fish)
FishEnum.parse(Fish.Salmon); // => âœ…
FishEnum.parse(0); // => âœ…
FishEnum.parse(2); // => âŒ
```

ä½ ä¹Ÿå¯ä»¥ä¼ å…¥ä¸€ä¸ªå¤–éƒ¨å£°æ˜çš„ TypeScript æšä¸¾ã€‚

```ts
enum Fish {
  Salmon = 0,
  Tuna = 1
}

const FishEnum = z.enum(Fish);
FishEnum.parse(Fish.Salmon); // => âœ…
FishEnum.parse(0); // => âœ…
FishEnum.parse(2); // => âŒ
```

<Callout>
**Zod 4** â€” è¿™å–ä»£äº† Zod 3 ä¸­çš„ `z.nativeEnum()` APIã€‚

è¯·æ³¨æ„ï¼Œä½¿ç”¨ TypeScript çš„ `enum` å…³é”®å­—[å¹¶ä¸æ¨è](https://www.totaltypescript.com/why-i-dont-like-typescript-enums)ã€‚
</Callout>

```ts
enum Fish {
  Salmon = "Salmon",
  Tuna = "Tuna",
  Trout = "Trout",
}

const FishEnum = z.enum(Fish);
```

### `.enum`

æå–æ¨¡å¼çš„å€¼ä¸ºç±»ä¼¼æšä¸¾çš„å¯¹è±¡ï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const FishEnum = z.enum(["Salmon", "Tuna", "Trout"]);

FishEnum.enum;
// => { Salmon: "Salmon", Tuna: "Tuna", Trout: "Trout" }
```
</Tab>
<Tab value="Zod Mini">
```ts
const FishEnum = z.enum(["Salmon", "Tuna", "Trout"]);

FishEnum.def.entries;
// => { Salmon: "Salmon", Tuna: "Tuna", Trout: "Trout" }
```
</Tab>
</Tabs>

### `.exclude()`

åˆ›å»ºæ–°æšä¸¾æ¨¡å¼ï¼Œæ’é™¤æŒ‡å®šå€¼ï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const FishEnum = z.enum(["Salmon", "Tuna", "Trout"]);
const TunaOnly = FishEnum.exclude(["Salmon", "Trout"]);
```
</Tab>
<Tab value="Zod Mini">
```ts
// no equivalent
 
```
</Tab>
</Tabs>

### `.extract()`

åˆ›å»ºæ–°æšä¸¾æ¨¡å¼ï¼Œä»…åŒ…å«æŒ‡å®šå€¼ï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const FishEnum = z.enum(["Salmon", "Tuna", "Trout"]);
const SalmonAndTroutOnly = FishEnum.extract(["Salmon", "Trout"]);
```
</Tab>
<Tab value="Zod Mini">
```ts
// no equivalent
 
```
</Tab>
</Tabs>

## å­—ç¬¦ä¸²å¸ƒå°”å€¼ [#stringbool]

> **ğŸ’ Zod 4 æ–°å¢**

æŸäº›æƒ…å†µä¸‹ï¼ˆå¦‚è§£æç¯å¢ƒå˜é‡ï¼‰ï¼Œå°†æŸäº›å­—ç¬¦ä¸²â€œå¸ƒå°”å€¼â€è§£æä¸ºçº¯ `boolean` å€¼éå¸¸æœ‰ç”¨ã€‚ä¸ºæ”¯æŒæ­¤åŠŸèƒ½ï¼ŒZod 4 å¼•å…¥äº† `z.stringbool()`ï¼š

```ts
const strbool = z.stringbool();

strbool.parse("true")         // => true
strbool.parse("1")            // => true
strbool.parse("yes")          // => true
strbool.parse("on")           // => true
strbool.parse("y")            // => true
strbool.parse("enabled")      // => true

strbool.parse("false");       // => false
strbool.parse("0");           // => false
strbool.parse("no");          // => false
strbool.parse("off");         // => false
strbool.parse("n");           // => false
strbool.parse("disabled");    // => false

strbool.parse(/* å…¶ä»–ä»»ä½•å€¼ */); // ZodError<[{ code: "invalid_value" }]>
```

è‡ªå®šä¹‰çœŸå€¼å’Œå‡å€¼ï¼š

```ts
// è¿™æ˜¯é»˜è®¤å€¼
z.stringbool({
  truthy: ["true", "1", "yes", "on", "y", "enabled"],
  falsy: ["false", "0", "no", "off", "n", "disabled"],
});
```

é»˜è®¤æƒ…å†µä¸‹ï¼Œæ¨¡å¼æ˜¯*ä¸åŒºåˆ†å¤§å°å†™*çš„ï¼›æ‰€æœ‰è¾“å…¥åœ¨ä¸ `truthy`/`falsy` å€¼æ¯”è¾ƒä¹‹å‰éƒ½ä¼šè½¬æ¢ä¸ºå°å†™ã€‚è¦ä½¿å…¶åŒºåˆ†å¤§å°å†™ï¼š

```ts
z.stringbool({
  case: "sensitive"
});
```


## å¯é€‰

ä½¿æ¨¡å¼*å¯é€‰*ï¼ˆå³å…è®¸ `undefined` è¾“å…¥ï¼‰ã€‚

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
z.optional(z.literal("yoda")); // æˆ– z.literal("yoda").optional()
```
</Tab>
<Tab value="Zod Mini">
```ts
z.optional(z.literal("yoda"));
```
</Tab>
</Tabs>

è¿”å›ä¸€ä¸ª `ZodOptional` å®ä¾‹ï¼ŒåŒ…è£…äº†åŸæ¨¡å¼ã€‚æå–å†…å±‚æ¨¡å¼ï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
optionalYoda.unwrap(); // ZodLiteral<"yoda">
```
</Tab>
<Tab value="Zod Mini">
```ts
optionalYoda.def.innerType; // ZodMiniLiteral<"yoda">
```
</Tab>
</Tabs>

## å¯ç©º

ä½¿æ¨¡å¼*å¯ç©º*ï¼ˆå³å…è®¸ `null` è¾“å…¥ï¼‰ã€‚

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
z.nullable(z.literal("yoda")); // æˆ– z.literal("yoda").nullable()
```
</Tab>
<Tab value="Zod Mini">
```ts
const nullableYoda = z.nullable(z.literal("yoda"));
```
</Tab>
</Tabs>

è¿”å›ä¸€ä¸ª `ZodNullable` å®ä¾‹ï¼ŒåŒ…è£…äº†åŸæ¨¡å¼ã€‚æå–å†…å±‚æ¨¡å¼ï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
nullableYoda.unwrap(); // ZodLiteral<"yoda">
```
</Tab>
<Tab value="Zod Mini">
```ts
nullableYoda.def.innerType; // ZodMiniLiteral<"yoda">
```
</Tab>
</Tabs>

## Nullish

ä½¿æ¨¡å¼*nullish*ï¼ˆå³å¯é€‰ä¸”å¯ç©ºï¼‰ï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const nullishYoda = z.nullish(z.literal("yoda"));
```
</Tab>
<Tab value="Zod Mini">
```ts
const nullishYoda = z.nullish(z.literal("yoda"));
```
</Tab>
</Tabs>

æ›´å¤šå…³äº[nullish](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#nullish-coalescing)æ¦‚å¿µï¼Œè¯·å‚é˜… TypeScript æ‰‹å†Œã€‚

## Unknown

Zod è‡´åŠ›äºä¸ TypeScript ç±»å‹ç³»ç»Ÿä¸€ä¸€å¯¹åº”ï¼Œå› æ­¤æä¾›ä»¥ä¸‹ç‰¹æ®Šç±»å‹çš„ APIï¼š

```ts
// å…è®¸ä»»æ„å€¼
z.any(); // æ¨æ–­ç±»å‹ï¼š`any`
z.unknown(); // æ¨æ–­ç±»å‹ï¼š`unknown`
```

## Never

æ²¡æœ‰ä»»ä½•å€¼å¯ä»¥é€šè¿‡éªŒè¯ã€‚

```ts
z.never(); // æ¨æ–­ç±»å‹ï¼š`never`
```

## å¯¹è±¡

å®šä¹‰å¯¹è±¡ç±»å‹ï¼š

```ts z.object
  // æ‰€æœ‰å±æ€§é»˜è®¤å¿…éœ€
  const Person = z.object({
    name: z.string(),
    age: z.number(),
  });

  type Person = z.infer<typeof Person>;
  // => { name: string; age: number; }
  ```
é»˜è®¤æ‰€æœ‰å±æ€§å¿…éœ€ã€‚ä½¿æŸäº›å±æ€§å¯é€‰ï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts z.object
const Dog = z.object({
  name: z.string(),
  age: z.number().optional(),
});

Dog.parse({ name: "Yeller" }); // âœ…
```
</Tab>
<Tab value="Zod Mini">
```ts z.object
const Dog = z.object({
  name: z.string(),
  age: z.optional(z.number())
});

Dog.parse({ name: "Yeller" }); // âœ…
```
</Tab>
</Tabs>



é»˜è®¤æƒ…å†µä¸‹ï¼Œæœªè¯†åˆ«çš„é”®ä¼šä»è§£æç»“æœä¸­*å‰¥é™¤*ï¼š

```ts z.object
Dog.parse({ name: "Yeller", extraKey: true });
// => { name: "Yeller" }
```

### `z.strictObject`

å®šä¹‰*ä¸¥æ ¼*æ¨¡å¼ï¼Œæ£€æµ‹åˆ°æœªçŸ¥é”®æ—¶æŠ¥é”™ï¼š

```ts z.object
const StrictDog = z.strictObject({
  name: z.string(),
});

StrictDog.parse({ name: "Yeller", extraKey: true });
// âŒ æŠ›å‡ºé”™è¯¯
```

### `z.looseObject`

å®šä¹‰*å®½æ¾*æ¨¡å¼ï¼Œå…è®¸æœªçŸ¥é”®é€šè¿‡ï¼š

```ts z.object
const LooseDog = z.looseObject({
  name: z.string(),
});

LooseDog.parse({ name: "Yeller", extraKey: true });
// => { name: "Yeller", extraKey: true }
```

### `.catchall()`

è¦å®šä¹‰ä¸€ä¸ª*é€šç”¨æ¨¡å¼*ï¼Œç”¨äºéªŒè¯ä»»ä½•æœªè¢«è¯†åˆ«çš„é”®ï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts z.object
const DogWithStrings = z.object({
  name: z.string(),
  age: z.number().optional(),
}).catchall(z.string());

DogWithStrings.parse({ name: "Yeller", extraKey: "extraValue" }); // âœ…
DogWithStrings.parse({ name: "Yeller", extraKey: 42 }); // âŒ
```
</Tab>
<Tab value="Zod Mini">
```ts z.object
const DogWithStrings = z.catchall(
  z.object({
    name: z.string(),
    age: z.number().optional(),
  }),
  z.string()
);

DogWithStrings.parse({ name: "Yeller", extraKey: "extraValue" }); // âœ…
DogWithStrings.parse({ name: "Yeller", extraKey: 42 }); // âŒ
```
</Tab>
</Tabs>


### `.shape`

è®¿é—®å†…éƒ¨æ¨¡å¼ï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
Dog.shape.name; // => string schema
Dog.shape.age; // => number schema
```
</Tab>
<Tab value="Zod Mini">
```ts
Dog.def.shape.name; // => string schema
Dog.def.shape.age; // => number schema
```
</Tab>
</Tabs>

### `.keyof()`

ä»å¯¹è±¡æ¨¡å¼çš„é”®åˆ›å»º `ZodEnum` æ¨¡å¼ï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const keySchema = Dog.keyof();
// => ZodEnum<["name", "age"]>
```
</Tab>
<Tab value="Zod Mini">
```ts
const keySchema = z.keyof(Dog);
// => ZodEnum<["name", "age"]>
```
</Tab>
</Tabs>

### `.extend()`

ä¸ºå¯¹è±¡æ¨¡å¼æ·»åŠ é¢å¤–å­—æ®µï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const DogWithBreed = Dog.extend({
  breed: z.string(),
});
```
</Tab>
<Tab value="Zod Mini">
```ts
const DogWithBreed = z.extend(Dog, {
  breed: z.string(),
});
```
</Tab>
</Tabs>

æ­¤ API å¯ç”¨äºè¦†ç›–ç°æœ‰å­—æ®µï¼è¯·å°å¿ƒä½¿ç”¨æ­¤åŠŸèƒ½ï¼å¦‚æœä¸¤ä¸ªæ¨¡å¼å…±äº«é”®ï¼ŒB å°†è¦†ç›– Aã€‚

<Callout>
**Alternative: spread syntax** â€” You can alternatively avoid `.extend()` altogether by creating a new object schema entirely. This makes the strictness level of the resulting schema visually obvious.

```ts
const DogWithBreed = z.object({ // or z.strictObject() or z.looseObject()...
  ...Dog.shape,
  breed: z.string(),
});
```

æ‚¨è¿˜å¯ä»¥ä½¿ç”¨æ­¤åŠŸèƒ½ä¸€æ¬¡åˆå¹¶å¤šä¸ªå¯¹è±¡ã€‚

```ts
const DogWithBreed = z.object({
  ...Animal.shape,
  ...Pet.shape,
  breed: z.string(),
});
```

è¿™ç§æ–¹æ³•æœ‰å‡ ä¸ªä¼˜ç‚¹ï¼š

1. å®ƒä½¿ç”¨è¯­è¨€çº§ç‰¹æ€§ï¼ˆ[æ‰©å±•è¯­æ³•](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax)ï¼‰ï¼Œè€Œä¸æ˜¯ç‰¹å®šäºåº“çš„ API
2. ç›¸åŒçš„è¯­æ³•åœ¨ Zod å’Œ Zod Mini ä¸­éƒ½é€‚ç”¨
3. å®ƒæ›´å…· `tsc` æ•ˆç‡â€”â€”åœ¨å¤§å‹æ¨¡å¼ä¸Šï¼Œ`.extend()` æ–¹æ³•å¯èƒ½ä¼šå¾ˆæ˜‚è´µï¼Œå¹¶ä¸”ç”±äº [TypeScript çš„é™åˆ¶](https://github.com/microsoft/TypeScript/pull/61505)ï¼Œå½“è°ƒç”¨é“¾å¼è°ƒç”¨æ—¶ï¼Œå®ƒçš„æˆæœ¬ä¼šå‘ˆå¹³æ–¹å¢é•¿
4. å¦‚æœæ‚¨æ„¿æ„ï¼Œå¯ä»¥é€šè¿‡ä½¿ç”¨ `z.strictObject()` æˆ– `z.looseObject()` æ¥æ›´æ”¹ç»“æœæ¨¡å¼çš„ä¸¥æ ¼æ€§çº§åˆ«
</Callout>

### `.safeExtend()`

`.safeExtend()` æ–¹æ³•çš„å·¥ä½œæ–¹å¼ç±»ä¼¼äº `.extend()`ï¼Œä½†å®ƒä¸ä¼šå…è®¸ä½ ç”¨ä¸å¯èµ‹å€¼çš„æ¨¡å¼è¦†ç›–å·²æœ‰å±æ€§ã€‚æ¢å¥è¯è¯´ï¼Œ`.safeExtend()` çš„ç»“æœå°†å…·æœ‰ä¸€ä¸ªæ¨æ–­ç±»å‹ï¼Œè¯¥ç±»å‹åœ¨ TypeScript çš„æ„ä¹‰ä¸Š [`extends`](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#conditional-type-constraints) åŸå§‹ç±»å‹ã€‚

```ts
z.object({ a: z.string() }).safeExtend({ a: z.string().min(5) }); // âœ…
z.object({ a: z.string() }).safeExtend({ a: z.any() }); // âœ…
z.object({ a: z.string() }).safeExtend({ a: z.number() });
//                                       ^  âŒ ZodNumber is not assignable 
```

ä½¿ç”¨ `.safeExtend()` æ¥æ‰©å±•åŒ…å«ç»†åŒ–çš„æ¨¡å¼ã€‚ï¼ˆå¸¸è§„çš„ `.extend()` åœ¨ç”¨äºåŒ…å«ç»†åŒ–çš„æ¨¡å¼æ—¶ä¼šæŠ›å‡ºé”™è¯¯ã€‚ï¼‰

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const Base = z.object({
  a: z.string(),
  b: z.string()
}).refine(user => user.a === user.b);

// Extended inherits the refinements of Base
const Extended = Base.safeExtend({
  a: z.string().min(10)
});
```
</Tab>
<Tab value="Zod Mini">
```ts
const Base = z.object({
  a: z.string(),
  b: z.string()
}).check(z.refine(user => user.a === user.b));

// Extended inherits the refinements of Base
const Extended = z.safeExtend(Base, {
  a: z.string().min(10)
});
```
</Tab>
</Tabs>

### `.pick()`

å€Ÿé‰´ TypeScript çš„å†…ç½®å·¥å…·ç±»å‹ `Pick` å’Œ `Omit`ï¼ŒZod æä¾›äº†ä¸“ç”¨ API ç”¨äºä»å¯¹è±¡æ¨¡å¼ä¸­é€‰æ‹©/å‰”é™¤æŸäº›é”®ã€‚

åˆå§‹æ¨¡å¼ï¼š

```ts z.object
const Recipe = z.object({
  title: z.string(),
  description: z.string().optional(),
  ingredients: z.array(z.string()),
});
// { title: string; description?: string | undefined; ingredients: string[] }
```
é€‰æ‹©æŸäº›é”®ï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts zod
const JustTheTitle = Recipe.pick({ title: true });
```
</Tab>
<Tab value="Zod Mini">
```ts
const JustTheTitle = z.pick(Recipe, { title: true });
```
</Tab>
</Tabs>


### `.omit()`

å‰”é™¤æŸäº›é”®ï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts zod
const RecipeNoId = Recipe.omit({ id: true });
```
</Tab>
<Tab value="Zod Mini">
```ts
const RecipeNoId = z.omit(Recipe, { id: true });
```
</Tab>
</Tabs>


### `.partial()`

ä¸ºæ–¹ä¾¿èµ·è§ï¼ŒZod æä¾›äº†ä¸“é—¨ APIï¼Œä½¿éƒ¨åˆ†æˆ–æ‰€æœ‰å±æ€§å˜ä¸ºå¯é€‰ï¼Œçµæ„Ÿæ¥è‡ª TypeScript å†…ç½®çš„ [`Partial`](https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype)ã€‚

ä½¿æ‰€æœ‰å­—æ®µå¯é€‰ï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts zod
const PartialRecipe = Recipe.partial();
// { title?: string | undefined; description?: string | undefined; ingredients?: string[] | undefined }
```
</Tab>
<Tab value="Zod Mini">
```ts
const PartialRecipe = z.partial(Recipe);
// { title?: string | undefined; description?: string | undefined; ingredients?: string[] | undefined }
```
</Tab>
</Tabs>

ä½¿æŒ‡å®šå±æ€§å¯é€‰ï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts zod
const RecipeOptionalIngredients = Recipe.partial({
  ingredients: true,
});
// { title: string; description?: string | undefined; ingredients?: string[] | undefined }
```
</Tab>
<Tab value="Zod Mini">
```ts
const RecipeOptionalIngredients = z.partial(Recipe, {
  ingredients: true,
});
// { title: string; description?: string | undefined; ingredients?: string[] | undefined }
```
</Tab>
</Tabs>

### `.required()`

Zod æä¾›äº†ä¸€ä¸ªä½¿éƒ¨åˆ†æˆ–æ‰€æœ‰å±æ€§*å¿…éœ€*çš„ APIï¼Œçµæ„Ÿæ¥è‡ª TypeScript å†…ç½®çš„ [`Required`](https://www.typescriptlang.org/docs/handbook/utility-types.html#requiredtype)ã€‚

ä½¿æ‰€æœ‰å±æ€§å¿…éœ€ï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts zod
const RequiredRecipe = Recipe.required();
// { title: string; description: string; ingredients: string[] }
```
</Tab>
<Tab value="Zod Mini">
```ts
const RequiredRecipe = z.required(Recipe);
// { title: string; description: string; ingredients: string[] }
```
</Tab>
</Tabs>

ä½¿æŒ‡å®šå±æ€§å¿…éœ€ï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts zod
const RecipeRequiredDescription = Recipe.required({description: true});
// { title: string; description: string; ingredients: string[] }
```
</Tab>
<Tab value="Zod Mini">
```ts
const RecipeRequiredDescription = z.required(Recipe, {description: true});
// { title: string; description: string; ingredients: string[] }
```
</Tab>
</Tabs>



## é€’å½’å¯¹è±¡

å®šä¹‰è‡ªå¼•ç”¨ç±»å‹ï¼Œä½¿ç”¨é”®çš„[getter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get)ã€‚è¿™è®© JavaScript åœ¨è¿è¡Œæ—¶è§£æå¾ªç¯æ¨¡å¼ã€‚

```ts
const Category = z.object({
  name: z.string(),
  get subcategories(){
    return z.array(Category)
  }
});

type Category = z.infer<typeof Category>;
// { name: string; subcategories: Category[] }
```

<Callout type="warn"> 
  è™½æ”¯æŒé€’å½’æ¨¡å¼ï¼Œä½†ä¼ å…¥å¾ªç¯æ•°æ®å°†å¯¼è‡´æ— é™å¾ªç¯ã€‚
</Callout>

ä¹Ÿå¯ä»¥è¡¨ç¤º*äº’ç›¸é€’å½’çš„ç±»å‹*ï¼š

```ts
const User = z.object({
  email: z.email(),
  get posts(){
    return z.array(Post)
  }
});

const Post = z.object({
  title: z.string(),
  get author(){
    return User
  }
});
```

æ‰€æœ‰å¯¹è±¡ APIï¼ˆå¦‚ `.pick()`ã€`.omit()`ã€`.required()`ã€`.partial()` ç­‰ï¼‰å‡å¦‚é¢„æœŸå·¥ä½œã€‚

### å¾ªç¯é”™è¯¯

ç”±äº TypeScript é™åˆ¶ï¼Œé€’å½’ç±»å‹æ¨æ–­å¯èƒ½å‡ºç°é—®é¢˜ï¼Œåªåœ¨æŸäº›åœºæ™¯æœ‰æ•ˆã€‚å¤æ‚ç±»å‹å¯èƒ½è§¦å‘å¦‚ä¸‹é€’å½’ç±»å‹é”™è¯¯ï¼š

```ts
const Activity = z.object({
  name: z.string(),
  get subactivities() {
    // ^ âŒ 'subactivities' éšå¼è¿”å›å€¼ç±»å‹ä¸º 'any'ï¼Œå› æ— è¿”å›ç±»å‹æ³¨è§£ä¸”ç›´æ¥æˆ–é—´æ¥è‡ªèº«å¼•ç”¨.ts(7023)

    return z.nullable(z.array(Activity));
  },
});
```

æ­¤æ—¶ï¼Œæ‚¨å¯ä»¥åœ¨å‡ºé”™ getter ä¸ŠåŠ ç±»å‹æ³¨è§£è§£å†³ï¼š

```ts
const Activity = z.object({
  name: z.string(),
  get subactivities(): z.ZodNullable<z.ZodArray<typeof Activity>> {
    return z.nullable(z.array(Activity));
  },
});
```

{/* ä¸€äº›é¿å…å¾ªç¯çš„ç»éªŒæ³•åˆ™ */}

{/* 
<Accordions>
  <Accordion title="è§£å†³é€’å½’æ¨¡å¼ä¸­çš„ç±»å‹é”™è¯¯">
    é€’å½’ç±»å‹æ¨æ–­æœ‰ä¸€å®šç¥ç§˜è‰²å½©ã€‚TypeScript åœ¨éƒ¨åˆ†å—é™åœºæ™¯æ”¯æŒæ­¤åŠŸèƒ½ã€‚æ ¹æ®ç”¨é€”ï¼Œå¯èƒ½å‡ºç°å¦‚ä¸‹é”™è¯¯ï¼š

    ```ts
    export const Activity = z.object({
      name: z.string(),
      get children() {
        // ^ âŒ 'children' éšå¼è¿”å›å€¼ç±»å‹ä¸º 'any'ï¼Œå› æ— è¿”å›ç±»å‹æ³¨è§£ä¸”ç›´æ¥æˆ–é—´æ¥è‡ªèº«å¼•ç”¨.ts(7023)

        return z.optional(z.array(Activity)); //.optional();
      },
    });
    ```

    ä¸€äº›ç»éªŒæ³•åˆ™ï¼š

    ### ä»…å¯¹è±¡ç±»å‹ 
    
    é€šå¸¸é€’å½’æ¨æ–­åªå¯¹ç›¸äº’å¼•ç”¨çš„å¯¹è±¡ç±»å‹æœ‰æ•ˆã€‚TypeScript å¯¹ getter é€’å½’å¯¹è±¡æœ‰ç‰¹æ®Šæ”¯æŒï¼ŒZod ä¾èµ–è¯¥ç‰¹æ€§ã€‚è‹¥åŠ å…¥éå¯¹è±¡ç±»å‹ï¼Œå¯èƒ½å‡ºç°é”™è¯¯ã€‚

    ```ts
    const Activity = z.object({
      name: z.string(),
      get children() { // âŒ ç±»å‹é”™è¯¯
        return z.optional(ActivityArray);
      },
    });

    const ActivityArray = z.array(Activity);
    ```

    æœ‰æ—¶é€šè¿‡ç±»å‹å®šä¹‰å¯ä»¥ç»•è¿‡æ­¤é™åˆ¶ã€‚


    ### é¿å…åµŒå¥—å‡½æ•°è°ƒç”¨
    
    `z.array()` å’Œ `z.optional()` æ¥å— Zod æ¨¡å¼ï¼ŒTypeScript ä¼šå¯¹å‚æ•°åšç±»å‹æ£€æŸ¥ï¼Œä»¥ç¡®ä¿æœ‰æ•ˆã€‚ä½†ç±»å‹æ£€æŸ¥ä¸é€’å½’æ¨æ–­éš¾ä»¥å…±å­˜ã€‚æ–¹æ³•ï¼ˆè€Œéå‡½æ•°ï¼‰æ²¡æœ‰è¯¥é—®é¢˜ã€‚å› æ­¤å°½å¯èƒ½ç”¨æ–¹æ³•ï¼ˆæŠ±æ­‰ Zod Mini ç”¨æˆ·ï¼‰ã€‚

    ```ts
    const Activity = z.object({
      name: z.string(),
      get subactivities() {
        // ^ âŒ 'subactivities' éšå¼è¿”å›å€¼ç±»å‹ä¸º 'any'ï¼Œå› æ— è¿”å›ç±»å‹æ³¨è§£ä¸”ç›´æ¥æˆ–é—´æ¥è‡ªèº«å¼•ç”¨.ts(7023)

        return z.union([z.null(), Activity]);
      },
    });
    ```

    ### ä½¿ç”¨ç±»å‹æ³¨è§£
    
    æœ‰ç–‘é—®æ—¶ï¼Œé€šå¸¸åœ¨ getter ä¸ŠåŠ ç±»å‹æ³¨è§£å³å¯è§„é¿é—®é¢˜ã€‚TypeScript é™åˆ¶å°¤å…¶åœ¨ Zod Mini ä¸­æ˜æ˜¾ã€‚

    ```ts
    import * as z from "zod";

    const Activity = z.object({
      name: z.string(),
      get subactivities(): z.ZodMiniDefault<z.ZodMiniArray<typeof Activity>> {
        return z._default(z.array(Activity), []);
      },
    });
    ```

  </Accordion>
</Accordions> */}

## æ•°ç»„

å®šä¹‰æ•°ç»„æ¨¡å¼ï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const stringArray = z.array(z.string()); // æˆ– z.string().array()
```
</Tab>
<Tab value="Zod Mini">
```ts
const stringArray = z.array(z.string());
```
</Tab>
</Tabs>

è®¿é—®æ•°ç»„å…ƒç´ çš„å†…å±‚æ¨¡å¼ï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
stringArray.unwrap(); // => string schema
```
</Tab>
<Tab value="Zod Mini">
```ts
stringArray.def.element; // => string schema
```
</Tab>
</Tabs>

Zod å®ç°äº†è‹¥å¹²æ•°ç»„ç‰¹å®šéªŒè¯ï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
z.array(z.string()).min(5); // è‡³å°‘åŒ…å« 5 é¡¹
z.array(z.string()).max(5); // æœ€å¤šåŒ…å« 5 é¡¹
z.array(z.string()).length(5); // æ°å¥½åŒ…å« 5 é¡¹
```
</Tab>
<Tab value="Zod Mini">
```ts
z.array(z.string()).check(z.minLength(5)); // must contain 5 or more items
z.array(z.string()).check(z.maxLength(5)); // must contain 5 or fewer items
z.array(z.string()).check(z.length(5)); // must contain 5 items exactly
```
</Tab>
</Tabs>

{/* ä¸ `.nonempty()` ä¸åŒï¼Œè¿™äº›æ–¹æ³•ä¸æ”¹å˜æ¨æ–­ç±»å‹ã€‚ */}

## å…ƒç»„

å…ƒç»„é€šå¸¸æ˜¯å›ºå®šé•¿åº¦æ•°ç»„ï¼Œæ¯ä¸ªç´¢å¼•æŒ‡å®šä¸åŒçš„æ¨¡å¼ã€‚

```ts
const MyTuple = z.tuple([
  z.string(),
  z.number(),
  z.boolean()
]);

type MyTuple = z.infer<typeof MyTuple>;
// [string, number, boolean]
```

æ·»åŠ å¯å˜é•¿ï¼ˆ"å‰©ä½™"ï¼‰å‚æ•°ï¼š

```ts
const variadicTuple = z.tuple([z.string()], z.number());
// => [string, ...number[]];
```

## è”åˆç±»å‹

è”åˆç±»å‹ï¼ˆ`A | B`ï¼‰ä»£è¡¨é€»è¾‘â€œæˆ–â€ã€‚Zod è”åˆæ¨¡å¼ä¾æ¬¡æ£€æŸ¥è¾“å…¥ï¼Œè¿”å›ç¬¬ä¸€ä¸ªéªŒè¯æˆåŠŸçš„é€‰é¡¹ã€‚

```ts
const stringOrNumber = z.union([z.string(), z.number()]);
// string | number

stringOrNumber.parse("foo"); // é€šè¿‡
stringOrNumber.parse(14);    // é€šè¿‡
```

è®¿é—®å†…éƒ¨é€‰é¡¹æ¨¡å¼ï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
stringOrNumber.options; // [ZodString, ZodNumber]
```
</Tab>
<Tab value="Zod Mini">
```ts
stringOrNumber.def.options; // [ZodString, ZodNumber]
```
</Tab>
</Tabs>

{/* æ–¹ä¾¿ç”¨æ³•ï¼š`.or` æ–¹æ³•ï¼š

```ts
const stringOrNumber = z.string().or(z.number());
``` */}

{/* **å¯é€‰å­—ç¬¦ä¸²éªŒè¯ï¼š**

è‹¥éªŒè¯å¯é€‰è¡¨å•è¾“å…¥ï¼Œå¯å°†æ‰€éœ€å­—ç¬¦ä¸²éªŒè¯ä¸ç©ºå­—ç¬¦ä¸²å­—é¢é‡è”åˆã€‚

ä¾‹ï¼šéªŒè¯å¯èƒ½ä¸ºç©ºæˆ–åŒ…å«[æœ‰æ•ˆ URL](#strings)çš„è¾“å…¥ï¼š

```ts
const optionalUrl = z.union([z.string().url().nullish(), z.literal("")]);

console.log(optionalUrl.safeParse(undefined).success); // true
console.log(optionalUrl.safeParse(null).success); // true
console.log(optionalUrl.safeParse("").success); // true
console.log(optionalUrl.safeParse("https://zod.dev").success); // true
console.log(optionalUrl.safeParse("not a valid url").success); // false
```

<br/> */}

## æ’ä»–è”åˆï¼ˆXORï¼‰

æ’ä»–è”åˆï¼ˆXORï¼‰æ˜¯ä¸€ç§è”åˆï¼Œå…¶ä¸­å¿…é¡»æ°å¥½æœ‰ä¸€ä¸ªé€‰é¡¹åŒ¹é…ã€‚ä¸æ™®é€šè”åˆåªè¦æœ‰ä»»æ„ä¸€ä¸ªé€‰é¡¹åŒ¹é…å°±æˆåŠŸä¸åŒï¼Œ`z.xor()`åœ¨æ²¡æœ‰é€‰é¡¹åŒ¹é…æˆ–æœ‰å¤šä¸ªé€‰é¡¹åŒ¹é…æ—¶éƒ½ä¼šå¤±è´¥ã€‚

```ts
const schema = z.xor([z.string(), z.number()]);

schema.parse("hello"); // âœ… passes
schema.parse(42);      // âœ… passes
schema.parse(true);    // âŒ fails (zero matches)
```

å½“ä½ æƒ³ç¡®ä¿é€‰é¡¹ä¹‹é—´äº’æ–¥æ—¶ï¼Œè¿™å¾ˆæœ‰ç”¨ï¼š

```ts
// Validate that exactly ONE of these matches
const payment = z.xor([
  z.object({ type: z.literal("card"), cardNumber: z.string() }),
  z.object({ type: z.literal("bank"), accountNumber: z.string() }),
]);

payment.parse({ type: "card", cardNumber: "1234" }); // âœ… passes
```

å¦‚æœè¾“å…¥å¯ä»¥åŒ¹é…å¤šä¸ªé€‰é¡¹ï¼Œ`z.xor()` å°†ä¼šå¤±è´¥ï¼š

```ts
const overlapping = z.xor([z.string(), z.any()]);
overlapping.parse("hello"); // âŒ fails (matches both string and any)
```

## å¸¦åˆ†è¾¨å­—æ®µçš„è”åˆ

[å¸¦åˆ†è¾¨å­—æ®µçš„è”åˆ](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions) æ˜¯ä¸€ç§ç‰¹æ®Šè”åˆï¼Œè¦æ±‚ a) æ‰€æœ‰é€‰é¡¹å‡ä¸ºå¯¹è±¡æ¨¡å¼ä¸” b) å…±äº«ç‰¹å®šé”®ï¼ˆâ€œåˆ†è¾¨å­—æ®µâ€ï¼‰ã€‚æ ¹æ®åˆ†è¾¨å­—æ®µçš„å€¼ï¼ŒTypeScript èƒ½ç²¾ç¡®ç¼©å°ç±»å‹ã€‚

```ts
type MyResult =
  | { status: "success"; data: string }
  | { status: "failed"; error: string };

function handleResult(result: MyResult){
  if(result.status === "success"){
    result.data; // string
  } else {
    result.error; // string
  }
}
```

å¯ä»¥ç”¨å¸¸è§„ `z.union()` è¡¨ç¤ºã€‚ä½†å¸¸è§„è”åˆæ˜¯*æœ´ç´ *çš„â€”ä¾åºæµ‹è¯•é€‰é¡¹ï¼Œè¿”å›é¦–ä¸ªæˆåŠŸã€‚å¤§è”åˆæ—¶å¯èƒ½è¾ƒæ…¢ã€‚

Zod æä¾›äº† `z.discriminatedUnion()`ï¼Œé€šè¿‡*åˆ†è¾¨å­—æ®µ*æé«˜è§£ææ•ˆç‡ã€‚

```ts
const MyResult = z.discriminatedUnion("status", [
  z.object({ status: z.literal("success"), data: z.string() }),
  z.object({ status: z.literal("failed"), error: z.string() }),
]);
```

æ¯ä¸ªé€‰é¡¹åº”è¯¥æ˜¯ä¸€ä¸ª *å¯¹è±¡æ¨¡å¼*ï¼Œå…¶åŒºåˆ†ç¬¦å±æ€§ï¼ˆä¸Šé¢ç¤ºä¾‹ä¸­çš„ `status`ï¼‰å¯¹åº”æŸä¸ªå­—é¢å€¼æˆ–ä¸€ç»„å€¼ï¼Œé€šå¸¸æ˜¯ `z.enum()`ã€`z.literal()`ã€`z.null()` æˆ– `z.undefined()`ã€‚

{/* 
<Callout>
  åœ¨ Zod 3 ä¸­ï¼Œå¿…é¡»å…ˆæŒ‡å®šåˆ†è¾¨å­—æ®µã€‚Zod 4 æ”¯æŒè‡ªåŠ¨æ£€æµ‹ï¼Œæ— éœ€æ‰‹åŠ¨æŒ‡å®šã€‚

  ```ts
  const MyResult = z.discriminatedUnion("status", [
    z.object({ status: z.literal("success"), data: z.string() }),
    z.object({ status: z.literal("failed"), error: z.string() }),
  ]);
  ```

  è‹¥æ— æ³•æ‰¾åˆ°åˆ†è¾¨å­—æ®µï¼ŒZod ä¼šåœ¨æ¨¡å¼åˆ›å»ºæ—¶æŠ›é”™ã€‚
</Callout> */}

<Accordions type="single">
<Accordion title="åµŒå¥—å¸¦åˆ†è¾¨å­—æ®µçš„è”åˆ">

  é«˜çº§ç”¨ä¾‹ä¸­ï¼Œåˆ†è¾¨è”åˆå¯åµŒå¥—ã€‚Zod ä¼šç¡®å®šæ¯å±‚æœ€ä½³è§£æç­–ç•¥ï¼Œåˆ©ç”¨å„å±‚åˆ†è¾¨å­—æ®µã€‚

  ```ts
  const BaseError = { status: z.literal("failed"), message: z.string() };
  const MyErrors = z.discriminatedUnion("code", [
    z.object({ ...BaseError, code: z.literal(400) }),
    z.object({ ...BaseError, code: z.literal(401) }),
    z.object({ ...BaseError, code: z.literal(500) }),
  ]);

  const MyResult = z.discriminatedUnion("status", [
    z.object({ status: z.literal("success"), data: z.string() }),
    MyErrors
  ]);
  ```

</Accordion>
</Accordions>


## äº¤å‰ç±»å‹

äº¤å‰ç±»å‹ (`A & B`) ä»£è¡¨é€»è¾‘â€œä¸”â€ã€‚

```ts
const a = z.union([z.number(), z.string()]);
const b = z.union([z.number(), z.boolean()]);
const c = z.intersection(a, b);

type c = z.infer<typeof c>; // => number
```

è¿™å¯¹åˆå¹¶ä¸¤ä¸ªå¯¹è±¡ç±»å‹å¾ˆæœ‰ç”¨ã€‚

```ts
const Person = z.object({ name: z.string() });
type Person = z.infer<typeof Person>;

const Employee = z.object({ role: z.string() });
type Employee = z.infer<typeof Employee>;

const EmployedPerson = z.intersection(Person, Employee);
type EmployedPerson = z.infer<typeof EmployedPerson>;
// Person & Employee
```

<Callout type="warn">
  åœ¨åˆå¹¶å¯¹è±¡æ¨¡å¼æ—¶ï¼Œä¼˜å…ˆä½¿ç”¨ [`A.extend(B)`](#extend) è€Œä¸æ˜¯äº¤é›†ã€‚ä½¿ç”¨ `.extend()` å°†ä¸ºæ‚¨æä¾›ä¸€ä¸ªæ–°çš„å¯¹è±¡æ¨¡å¼ï¼Œè€Œ `z.intersection(A, B)` è¿”å›ä¸€ä¸ª `ZodIntersection` å®ä¾‹ï¼Œè¯¥å®ä¾‹ç¼ºå°‘åƒ `pick` å’Œ `omit` è¿™æ ·çš„å…¬å…±å¯¹è±¡æ–¹æ³•ã€‚
</Callout>

## Record ç±»å‹

Record æ¨¡å¼ç”¨äºéªŒè¯å¦‚ `Record<string, string>` ç±»å‹ã€‚

### `z.record`

```ts
const IdCache = z.record(z.string(), z.string());
type IdCache = z.infer<typeof IdCache>; // Record<string, string>

IdCache.parse({
  carlotta: "77d2586b-9e8e-4ecf-8b21-ea7e0530eadd",
  jimmie: "77d2586b-9e8e-4ecf-8b21-ea7e0530eadd",
});
```

é”®æ¨¡å¼å¯ä¸ºä»»ä½•å¯èµ‹å€¼ç»™ `string | number | symbol` çš„ Zod æ¨¡å¼ã€‚

```ts
const Keys = z.union([z.string(), z.number(), z.symbol()]);
const AnyObject = z.record(Keys, z.unknown());
// Record<string | number | symbol, unknown>
```

ä½¿ç”¨æšä¸¾å®šä¹‰é”®çš„å¯¹è±¡æ¨¡å¼ï¼š

```ts
const Keys = z.enum(["id", "name", "email"]);
const Person = z.record(Keys, z.string());
// { id: string; name: string; email: string }
```

### `z.partialRecord`


<Callout>
  **Zod 4** â€” åœ¨ Zod 4 ä¸­ï¼Œè‹¥å°† `z.enum` ä¼ ç»™ `z.record()` ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°ï¼ŒZod ä¼šè¯¦å°½æ£€æŸ¥è¾“å…¥å¯¹è±¡æ˜¯å¦åŒ…å«æ‰€æœ‰æšä¸¾å€¼ä½œä¸ºé”®ã€‚æ­¤è¡Œä¸ºä¸ TypeScript ä¿æŒä¸€è‡´ï¼š

  ```ts
  type MyRecord = Record<"a" | "b", string>;
  const myRecord: MyRecord = { a: "foo", b: "bar" }; // âœ…
  const myRecord: MyRecord = { a: "foo" }; // âŒ ç¼ºå°‘å¿…éœ€é”® `b`
  ```

  åœ¨ Zod 3 ä¸­ï¼Œæ²¡æœ‰æ£€æŸ¥ç©·å°½æ€§ã€‚è¦å¤åˆ¶æ—§çš„è¡Œä¸ºï¼Œè¯·ä½¿ç”¨ `z.partialRecord()`ã€‚

</Callout>

è‹¥éœ€å®šä¹‰*éƒ¨åˆ†* Record ç±»å‹ï¼Œä½¿ç”¨ `z.partialRecord()` ã€‚æ­¤æ–¹æ³•è·³è¿‡ Zod å¯¹ `z.enum()` å’Œ `z.literal()` é”®æ¨¡å¼çš„è¯¦å°½æ£€æŸ¥ã€‚

```ts
const Keys = z.enum(["id", "name", "email"]).or(z.never()); 
const Person = z.partialRecord(Keys, z.string());
// { id?: string; name?: string; email?: string }
```

### `z.looseRecord`

By default, `z.record()` errors on keys that don't match the key schema. Use `z.looseRecord()` to pass through non-matching keys unchanged. This is particularly useful when combined with intersections to model multiple pattern properties:

```ts
const schema = z.object({ name: z.string() }).passthrough()
  .and(z.looseRecord(z.string().regex(/^S_/), z.string()))
  .and(z.looseRecord(z.string().regex(/^N_/), z.number()));

schema.parse({ 
  name: "John",
  other: "value",    // passes through unchanged
  S_foo: "bar",     // validated as string
  N_count: 123,     // validated as number
});
```

<Accordions>
<Accordion title="å…³äºæ•°å­—é”®çš„è¯´æ˜">

å°½ç®¡ TypeScript å…è®¸å®šä¹‰ `Record<number, unknown>` ç­‰æ•°å­—é”®çš„ Record ç±»å‹ï¼ŒJavaScript ä¸­æ•°å­—é”®å®é™…ä¸Šä¸å­˜åœ¨ï¼Œéƒ½ä¼šè½¬æ¢ä¸ºå­—ç¬¦ä¸²ã€‚

```ts
const myObject = { 1: "one" };

Object.keys(myObject); 
// => ["1"]
```

å¦‚ä¸Šæ‰€ç¤ºï¼ŒJS ä¼šå°†æ‰€æœ‰æ•°å­—é”®è‡ªåŠ¨è½¬æ¢ä¸ºå­—ç¬¦ä¸²ã€‚å› æ­¤ï¼Œåœ¨ `z.record()` ä¸­ä½¿ç”¨ `z.number()` ä½œä¸ºé”®æ¨¡å¼ï¼Œè§£ææ—¶ä¼šæŠ›é”™ï¼Œä½† Zod ä¸ºä¿æŒä¸ TypeScript çš„ä¸€è‡´æ€§ï¼Œä»å…è®¸æ­¤ç”¨æ³•ã€‚

</Accordion></Accordions>

## Map ç±»å‹

```ts
const StringNumberMap = z.map(z.string(), z.number());
type StringNumberMap = z.infer<typeof StringNumberMap>; // Map<string, number>

const myMap: StringNumberMap = new Map();
myMap.set("one", 1);
myMap.set("two", 2);

StringNumberMap.parse(myMap);
```

## Set ç±»å‹

```ts
const NumberSet = z.set(z.number());
type NumberSet = z.infer<typeof NumberSet>; // Set<number>

const mySet: NumberSet = new Set();
mySet.add(1);
mySet.add(2);
NumberSet.parse(mySet);
```

Set æ¨¡å¼å¯ç”¨ä»¥ä¸‹æ–¹æ³•è¿›ä¸€æ­¥çº¦æŸã€‚

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
z.set(z.string()).min(5); // è‡³å°‘ 5 ä¸ªå…ƒç´ 
z.set(z.string()).max(5); // æœ€å¤š 5 ä¸ªå…ƒç´ 
z.set(z.string()).size(5); // æ°å¥½ 5 ä¸ªå…ƒç´ 
```
</Tab>
<Tab value='Zod Mini'>
```ts
z.set(z.string()).check(z.minSize(5)); // è‡³å°‘ 5 ä¸ªå…ƒç´ 
z.set(z.string()).check(z.maxSize(5)); // æœ€å¤š 5 ä¸ªå…ƒç´ 
z.set(z.string()).check(z.size(5)); // æ°å¥½ 5 ä¸ªå…ƒç´ 
```
</Tab>
</Tabs>

## æ–‡ä»¶

éªŒè¯ `File` å®ä¾‹ï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const fileSchema = z.file();

fileSchema.min(10_000); // minimum .size (bytes)
fileSchema.max(1_000_000); // maximum .size (bytes)
fileSchema.mime("image/png"); // MIME type
fileSchema.mime(["image/png", "image/jpeg"]); // multiple MIME types
```

</Tab>
<Tab value='Zod Mini'>
```ts
const fileSchema = z.file();

fileSchema.check(
  z.minSize(10_000), // minimum .size (bytes)
  z.maxSize(1_000_000), // maximum .size (bytes)
  z.mime("image/png"), // MIME type
  z.mime(["image/png", "image/jpeg"]); // multiple MIME types
)
```
</Tab>
</Tabs>

## Promise

<Callout type="warn">
  **å·²å¼ƒç”¨** â€” `z.promise()` åœ¨ Zod 4 ä¸­å·²å¼ƒç”¨ã€‚æœ‰æ•ˆçš„ä½¿ç”¨åœºæ™¯æå°‘ã€‚è‹¥æ€€ç–‘å€¼æ˜¯ `Promise`ï¼Œåº”åœ¨ Zod éªŒè¯å‰å…ˆ `await`ã€‚
</Callout>

<Accordions type="single"><Accordion title="æŸ¥çœ‹ z.promise() æ–‡æ¡£">

```ts
const numberPromise = z.promise(z.number());
```

è§£æ Promise çš„æ–¹å¼ç¨æœ‰ä¸åŒã€‚éªŒè¯åˆ†ä¸¤æ­¥ï¼š

1. åŒæ­¥æ£€æŸ¥è¾“å…¥æ˜¯å¦ä¸º Promise å®ä¾‹ï¼ˆå³å« `.then` å’Œ `.catch` æ–¹æ³•çš„å¯¹è±¡ï¼‰ã€‚
2. åˆ©ç”¨ `.then` ç»™ Promise é™„åŠ é¢å¤–éªŒè¯ã€‚éœ€ç”¨ `.catch` å¤„ç†éªŒè¯å¤±è´¥ã€‚

```ts
numberPromise.parse("tuna");
// ZodError: é Promise ç±»å‹ï¼šstring

numberPromise.parse(Promise.resolve("tuna"));
// => Promise<number>

const test = async () => {
  await numberPromise.parse(Promise.resolve("tuna"));
  // ZodError: éæ•°å­—ç±»å‹ï¼šstring

  await numberPromise.parse(Promise.resolve(3.14));
  // => 3.14
};
```

</Accordion></Accordions>

## instanceof éªŒè¯

ä½¿ç”¨ `z.instanceof` éªŒè¯è¾“å…¥æ˜¯å¦ä¸ºæŒ‡å®šç±»çš„å®ä¾‹ã€‚é€‚åˆéªŒè¯æ¥è‡ªç¬¬ä¸‰æ–¹åº“çš„ç±»å®ä¾‹ã€‚

```ts
class Test {
  name: string;
}

const TestSchema = z.instanceof(Test);

TestSchema.parse(new Test()); // âœ…
TestSchema.parse("whatever"); // âŒ
```

### å±æ€§

è¦éªŒè¯ç±»å®ä¾‹çš„ç‰¹å®šå±æ€§æ˜¯å¦ç¬¦åˆ Zod æ¨¡å¼ï¼š

```ts
const blobSchema = z.instanceof(URL).check(
  z.property("protocol", z.literal("https:" as string, "Only HTTPS allowed"))
);

blobSchema.parse(new URL("https://example.com")); // âœ…
blobSchema.parse(new URL("http://example.com")); // âŒ
```

`z.property()` API å¯ä»¥ä¸ä»»ä½•æ•°æ®ç±»å‹ä¸€èµ·ä½¿ç”¨ï¼ˆä½†åœ¨ä¸ `z.instanceof()` ç»“åˆä½¿ç”¨æ—¶æœ€ä¸ºæœ‰æ•ˆï¼‰ã€‚

```ts
const blobSchema = z.string().check(
  z.property("length", z.number().min(10))
);

blobSchema.parse("hello there!"); // âœ…
blobSchema.parse("hello."); // âŒ
```

## ç²¾ç‚¼éªŒè¯

æ¯ä¸ª Zod æ¨¡å¼éƒ½å­˜æœ‰ä¸€ç»„*ç²¾ç‚¼*æ•°ç»„ã€‚ç²¾ç‚¼ç”¨äºæ‰§è¡Œ Zod æœ¬èº«æ— å†…ç½® API çš„è‡ªå®šä¹‰éªŒè¯ã€‚

### `.refine()`

{/* <Callout>
  æ£€æŸ¥äº‹å®ä¸Šä¸ä¼šä¸”ä¸èƒ½æ”¹å˜æ¨¡å¼çš„æ¨æ–­ç±»å‹ã€‚
</Callout>

### `.refine()` */}

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const myString = z.string().refine((val) => val.length <= 255);
```
</Tab>
<Tab value="Zod Mini">
```ts
const myString = z.string().check(z.refine((val) => val.length <= 255));
```
</Tab>
</Tabs>

<Callout type="warn">
  ç²¾ç‚¼å‡½æ•°ä¸åº”æŠ›å¼‚å¸¸ï¼Œä¸”åº”è¿”å›å‡å€¼è¡¨ç¤ºå¤±è´¥ã€‚æŠ›å‡ºé”™è¯¯ä¸è¢« Zod æ•è·ã€‚
</Callout>

#### `error` 

è¦è‡ªå®šä¹‰é”™è¯¯æ¶ˆæ¯ï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const myString = z.string().refine((val) => val.length > 8, { 
  error: "Too short!" 
});
```
</Tab>
<Tab value="Zod Mini">
```ts
const myString = z.string().check(
  z.refine((val) => val.length > 8, { error: "Too short!" })
);
```
</Tab>
</Tabs>

#### `abort` 

é»˜è®¤æƒ…å†µä¸‹ï¼ŒéªŒè¯é—®é¢˜è§†ä¸º*å¯ç»§ç»­*ï¼Œå³æ‰€æœ‰æ£€æŸ¥éƒ½ä¼šä¾æ¬¡æ‰§è¡Œï¼Œå³ä¾¿å‰é¢å‘ç”Ÿé”™è¯¯ã€‚æ­¤è¡Œä¸ºé€šå¸¸æœ‰åˆ©ï¼Œå¯ä¸€æ¬¡å‘ç°å°½å¯èƒ½å¤šé”™è¯¯ã€‚

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const myString = z.string()
  .refine((val) => val.length > 8, { error: "Too short!" })
  .refine((val) => val === val.toLowerCase(), { error: "Must be lowercase" });
  

const result = myString.safeParse("OH NO");
result.error?.issues;
/* [
  { "code": "custom", "message": "Too short!" },
  { "code": "custom", "message": "Must be lowercase" }
] */
```
</Tab>
<Tab value="Zod Mini">
```ts
const myString = z.string().check(
  z.refine((val) => val.length > 8, { error: "Too short!" }),
  z.refine((val) => val === val.toLowerCase(), { error: "Must be lowercase" })
);

const result = z.safeParse(myString, "OH NO");
result.error?.issues;
/* [
  { "code": "custom", "message": "Too short!" },
  { "code": "custom", "message": "Must be lowercase" }
] */
```
</Tab>
</Tabs>

è¦å°†ç‰¹å®šçš„ç»†åŒ–æ ‡è®°ä¸º*ä¸å¯ç»§ç»­*ï¼Œè¯·ä½¿ç”¨`abort`å‚æ•°ã€‚å¦‚æœæ£€æŸ¥å¤±è´¥ï¼ŒéªŒè¯å°†ç»ˆæ­¢ã€‚

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const myString = z.string()
  .refine((val) => val.length > 8, { error: "Too short!", abort: true })
  .refine((val) => val === val.toLowerCase(), { error: "Must be lowercase", abort: true });


const result = myString.safeParse("OH NO");
result.error?.issues;
// => [{ "code": "custom", "message": "Too short!" }]
```
</Tab>
<Tab value="Zod Mini">
```ts
const myString = z.string().check(
  z.refine((val) => val.length > 8, { error: "Too short!", abort: true }),
  z.refine((val) => val === val.toLowerCase(), { error: "Must be lowercase", abort: true })
);

const result = z.safeParse(myString, "OH NO");
result.error?.issues;
// [ { "code": "custom", "message": "Too short!" }]
```
</Tab>
</Tabs>

#### `path`

è¦è‡ªå®šä¹‰é”™è¯¯è·¯å¾„ï¼Œè¯·ä½¿ç”¨ `path` å‚æ•°ã€‚è¿™é€šå¸¸ä»…åœ¨å¯¹è±¡æ¨¡å¼çš„ä¸Šä¸‹æ–‡ä¸­æœ‰ç”¨ã€‚

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const passwordForm = z
  .object({
    password: z.string(),
    confirm: z.string(),
  })
  .refine((data) => data.password === data.confirm, {
    message: "Passwords don't match",
    path: ["confirm"], // é”™è¯¯è·¯å¾„
  });
```
</Tab>
<Tab value="Zod Mini">
```ts
const passwordForm = z
  .object({
    password: z.string(),
    confirm: z.string(),
  })
  .check(z.refine((data) => data.password === data.confirm, {
    message: "Passwords don't match",
    path: ["confirm"], // é”™è¯¯è·¯å¾„
  }));
```
</Tab>
</Tabs>

è¿™ä¼šå°† `path` è®¾ç½®ä¸ºç›¸å…³é—®é¢˜ï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const result = passwordForm.safeParse({ password: "asdf", confirm: "qwer" });
result.error.issues;
/* [{
  "code": "custom",
  "path": [ "confirm" ],
  "message": "Passwords don't match"
}] */
```
</Tab>
<Tab value="Zod Mini">
```ts
const result = z.safeParse(passwordForm, { password: "asdf", confirm: "qwer" });
result.error.issues;
/* [{
  "code": "custom",
  "path": [ "confirm" ],
  "message": "Passwords don't match"
}] */
```
</Tab>
</Tabs>

è¦å®šä¹‰ä¸€ä¸ªå¼‚æ­¥ç»†åŒ–ï¼Œåªéœ€ä¼ é€’ä¸€ä¸ª `async` å‡½æ•°ï¼š

```ts
const userId = z.string().refine(async (id) => {
  // éªŒè¯ ID æ˜¯å¦å­˜åœ¨æ•°æ®åº“
  return true;
});
```

<Callout>
  è‹¥ä½¿ç”¨å¼‚æ­¥ç²¾ç‚¼ï¼Œè§£ææ•°æ®æ—¶å¿…é¡»è°ƒç”¨ `.parseAsync` ï¼Œå¦åˆ™ Zod ä¼šæŠ›é”™ã€‚

  <Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
  <Tab value="Zod">
  ```ts
  const result = await userId.parseAsync("abc123");
  ```
  </Tab>
  <Tab value="Zod Mini">
  ```ts
  const result = await z.parseAsync(userId, "abc123");
  ```
  </Tab>
  </Tabs>
</Callout>

#### `when`

> **æ³¨æ„** â€” è¿™æ˜¯ä¸€ä¸ªé«˜çº§ç”¨æˆ·åŠŸèƒ½ï¼Œç»å¯¹å¯èƒ½è¢«æ»¥ç”¨ï¼Œä»è€Œå¢åŠ æœªæ•è·é”™è¯¯çš„æ¦‚ç‡ï¼Œè¿™äº›é”™è¯¯æºè‡ªäºæ‚¨çš„ä¿®é¥°ã€‚

é»˜è®¤æƒ…å†µä¸‹ï¼Œå¦‚æœå·²ç»é‡åˆ°ä»»ä½•*ä¸å¯ç»§ç»­*çš„é—®é¢˜ï¼Œä¿®é¥°å°†ä¸ä¼šè¿è¡Œã€‚Zod ä¼šä»”ç»†ç¡®ä¿å€¼çš„ç±»å‹ç­¾ååœ¨ä¼ é€’ç»™ä»»ä½•ä¿®é¥°å‡½æ•°ä¹‹å‰æ˜¯æ­£ç¡®çš„ã€‚

```ts
const schema = z.string().refine((val) => {
  return val.length > 8
});

schema.parse(1234); // invalid_type: refinement won't be executed
```

åœ¨æŸäº›æƒ…å†µä¸‹ï¼Œæ‚¨å¸Œæœ›æ›´ç²¾ç»†åœ°æ§åˆ¶ä½•æ—¶è¿è¡Œä¼˜åŒ–ã€‚ä¾‹å¦‚ï¼Œè€ƒè™‘è¿™ä¸ªâ€œå¯†ç ç¡®è®¤â€æ£€æŸ¥ï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const schema = z
  .object({
    password: z.string().min(8),
    confirmPassword: z.string(),
    anotherField: z.string(),
  })
  .refine((data) => data.password === data.confirmPassword, {
    message: "Passwords do not match",
    path: ["confirmPassword"],
  });

schema.parse({
  password: "asdf",
  confirmPassword: "asdf",
  anotherField: 1234 // âŒ this error will prevent the password check from running
});
```
</Tab>
<Tab value="Zod Mini">
```ts
const schema = z
  .object({
    password: z.string().check(z.minLength(8)),
    confirmPassword: z.string(),
    anotherField: z.string(),
  })
  .check(z.refine((data) => data.password === data.confirmPassword, {
    message: "Passwords do not match",
    path: ["confirmPassword"],
  }));

schema.parse({
  password: "asdf",
  confirmPassword: "asdf",
  anotherField: 1234 // âŒ this error will prevent the password check from running
});
```
</Tab>
</Tabs>

An error on `anotherField` will prevent the password confirmation check from executing, even though the check doesn't depend on `anotherField`. To control when a refinement will run, use the `when` parameter:

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const schema = z
  .object({
    password: z.string().min(8),
    confirmPassword: z.string(),
    anotherField: z.string(),
  })
  .refine((data) => data.password === data.confirmPassword, {
    message: "Passwords do not match",
    path: ["confirmPassword"],

    // run if password & confirmPassword are valid
    when(payload) { // [!code ++]
      return schema // [!code ++]
        .pick({ password: true, confirmPassword: true }) // [!code ++]
        .safeParse(payload.value).success; // [!code ++]
    },  // [!code ++]
  });

schema.parse({
  password: "asdf",
  confirmPassword: "asdf",
  anotherField: 1234 // âŒ this error will not prevent the password check from running
});
```
</Tab>
<Tab value="Zod Mini">
```ts
const schema = z
  .object({
    password: z.string().min(8),
    confirmPassword: z.string(),
    anotherField: z.string(),
  })
  .check(z.refine((data) => data.password === data.confirmPassword, {
    message: "Passwords do not match",
    path: ["confirmPassword"],
    when(payload) { // [!code ++]
      // no issues with `password` or `confirmPassword` // [!code ++]
      return payload.issues.every((iss) => { // [!code ++]
        const firstPathEl = iss.path?.[0]; // [!code ++]
        return firstPathEl !== "password" && firstPathEl !== "confirmPassword"; // [!code ++]
      }); // [!code ++]
    },  // [!code ++]
  }));

schema.parse({
  password: "asdf",
  confirmPassword: "asdf",
  anotherField: 1234 // âŒ this error will prevent the password check from running
});
```
</Tab>
</Tabs>


### `.superRefine()`
    

å¸¸è§„çš„ `.refine` API ä»…ç”Ÿæˆä¸€ä¸ªå¸¦æœ‰ `"custom"` é”™è¯¯ä»£ç çš„é—®é¢˜ï¼Œä½† `.superRefine()` ä½¿å¾—ä½¿ç”¨ Zod çš„ä»»ä½• [å†…éƒ¨é—®é¢˜ç±»å‹](https://github.com/colinhacks/zod/blob/main/packages/zod/src/v4/core/errors.ts) åˆ›å»ºå¤šä¸ªé—®é¢˜æˆä¸ºå¯èƒ½ã€‚

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const UniqueStringArray = z.array(z.string()).superRefine((val, ctx) => {
  if (val.length > 3) {
    ctx.addIssue({
      code: "too_big",
      maximum: 3,
      origin: "array",
      inclusive: true,
      message: "Too many items ğŸ˜¡",
      input: val,
    });
  }

  if (val.length !== new Set(val).size) {
    ctx.addIssue({
      code: "custom",
      message: `No duplicates allowed.`,
      input: val,
    });
  }
});


```
</Tab>
<Tab value="Zod Mini">
```ts
const UniqueStringArray = z.array(z.string()).check(
  z.superRefine((val, ctx) => {
    if (val.length > 3) {
      ctx.addIssue({
        code: "too_big",
        maximum: 3,
        origin: "array",
        inclusive: true,
        message: "Too many items ğŸ˜¡",
        input: val,
      });
    }

    if (val.length !== new Set(val).size) {
      ctx.addIssue({
        code: "custom",
        message: `No duplicates allowed.`,
        input: val,
      });
    }
  })
);
```
</Tab>
</Tabs>

### `.check()`

<Callout>
**Note** â€” The `.check()` API is a more low-level API that's generally more complex than `.superRefine()`. It can be faster in performance-sensitive code paths, but it's also more verbose.
</Callout>

<Accordions>
<Accordion title="View example">
`.refine()` æ˜¯ `.check()` çš„è¯­æ³•ç³–ï¼Œåè€…æ›´çµæ´»ï¼ˆä½†æ›´å•°å—¦ï¼‰ã€‚æ‚¨å¯ä»¥ç”¨å®ƒåœ¨å•ä¸ªç²¾ç‚¼ä¸­äº§ç”Ÿå¤šä¸ªé—®é¢˜ï¼Œæˆ–å®Œå…¨æ§åˆ¶é—®é¢˜å¯¹è±¡ã€‚

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const UniqueStringArray = z.array(z.string()).check((ctx) => {
  if (ctx.value.length > 3) {
    // full control of issue objects
    ctx.issues.push({
      code: "too_big",
      maximum: 3,
      origin: "array",
      inclusive: true,
      message: "Too many items ğŸ˜¡",
      input: ctx.value
    });
  }

  // create multiple issues in one refinement
  if (ctx.value.length !== new Set(ctx.value).size) {
    ctx.issues.push({
      code: "custom",
      message: `No duplicates allowed.`,
      input: ctx.value,
      continue: true // ä½¿æ­¤é—®é¢˜å¯ç»§ç»­ï¼ˆé»˜è®¤ï¼šfalseï¼‰
    });
  }
});
```
</Tab>
<Tab value="Zod Mini">
```ts
const UniqueStringArray = z.array(z.string()).check((ctx) => {
  // full control of issue objects
  if (ctx.value.length > 3) {
    ctx.issues.push({
      code: "too_big",
      maximum: 3,
      origin: "array",
      inclusive: true,
      message: "Too many items ğŸ˜¡",
      input: ctx.value
    });
  }

// create multiple issues in one refinement
  if (ctx.value.length !== new Set(ctx.value).size) {
    ctx.issues.push({
      code: "custom",
      message: `No duplicates allowed.`,
      input: ctx.value,
      continue: true // ä½¿æ­¤é—®é¢˜å¯ç»§ç»­ï¼ˆé»˜è®¤ï¼šfalseï¼‰
    });
  }
});
```
</Tab>
</Tabs>
</Accordion>
</Accordions>

## ç¼–è§£ç å™¨

> **æ–°** â€” åœ¨ Zod 4.1 ä¸­å¼•å…¥ã€‚æœ‰å…³æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚é˜…ä¸“é—¨çš„ [ç¼–è§£ç å™¨](/codecs) é¡µé¢ã€‚

ç¼–è§£ç å™¨æ˜¯ä¸€ç§ç‰¹æ®Šçš„æ¨¡å¼ï¼Œå®ç°åœ¨ä¸¤ä¸ªå…¶ä»–æ¨¡å¼ä¹‹é—´çš„ *åŒå‘è½¬æ¢*ã€‚

```ts
const stringToDate = z.codec(
  z.iso.datetime(),  // input schema: ISO date string
  z.date(),          // output schema: Date object
  {
    decode: (isoString) => new Date(isoString), // ISO string â†’ Date
    encode: (date) => date.toISOString(),       // Date â†’ ISO string
  }
);
```

å¸¸è§„çš„ `.parse()` æ“ä½œæ‰§è¡Œ *å‰å‘å˜æ¢*ã€‚å®ƒè°ƒç”¨ç¼–è§£ç å™¨çš„ `decode` å‡½æ•°ã€‚

```ts
stringToDate.parse("2024-01-15T10:30:00.000Z"); // => Date
```

æ‚¨å¯ä»¥é€‰æ‹©ä½¿ç”¨é¡¶çº§çš„ `z.decode()` å‡½æ•°ã€‚ä¸æ¥å— `unknown` è¾“å…¥çš„ `.parse()` ä¸åŒï¼Œ`z.decode()` æœŸæœ›ä¸€ä¸ªå¼ºç±»å‹çš„è¾“å…¥ï¼ˆåœ¨æ­¤ç¤ºä¾‹ä¸­ä¸º `string`ï¼‰ã€‚

```ts
z.decode(stringToDate, "2024-01-15T10:30:00.000Z"); // => Date
```

è¦æ‰§è¡Œ*åå‘å˜æ¢*ï¼Œè¯·ä½¿ç”¨åå‡½æ•°ï¼š`z.encode()`ã€‚

```ts
z.encode(stringToDate, new Date("2024-01-15")); // => "2024-01-15T00:00:00.000Z"
```

è¯·å‚é˜…ä¸“é—¨çš„ [ç¼–è§£ç å™¨](/codecs) é¡µé¢ä»¥è·å–æ›´å¤šä¿¡æ¯ã€‚è¯¥é¡µé¢åŒ…å«æ‚¨å¯ä»¥å¤åˆ¶/ç²˜è´´åˆ°é¡¹ç›®ä¸­çš„å¸¸ç”¨ç¼–è§£ç å™¨çš„å®ç°ï¼š

- [**`stringToNumber`**](/codecs#stringtonumber)
- [**`stringToInt`**](/codecs#stringtoint)
- [**`stringToBigInt`**](/codecs#stringtobigint)
- [**`numberToBigInt`**](/codecs#numbertobigint)
- [**`isoDatetimeToDate`**](/codecs#isodatetimetodate)
- [**`epochSecondsToDate`**](/codecs#epochsecondstodate)
- [**`epochMillisToDate`**](/codecs#epochmillistodate)
- [**`jsonCodec`**](/codecs#jsoncodec)
- [**`utf8ToBytes`**](/codecs#utf8tobytes)
- [**`bytesToUtf8`**](/codecs#bytestoutf8)
- [**`base64ToBytes`**](/codecs#base64tobytes)
- [**`base64urlToBytes`**](/codecs#base64urltobytes)
- [**`hexToBytes`**](/codecs#hextobytes)
- [**`stringToURL`**](/codecs#stringtourl)
- [**`stringToHttpURL`**](/codecs#stringtohttpurl)
- [**`uriComponent`**](/codecs#uricomponent)
- [**`stringToBoolean`**](/codecs#stringtoboolean)

## ç®¡é“

æ¨¡å¼å¯ä»¥é“¾æ¥åœ¨ä¸€èµ·å½¢æˆâ€œç®¡é“â€ã€‚ç®¡é“åœ¨ä¸[è½¬æ¢](#transforms)ç»“åˆä½¿ç”¨æ—¶ç‰¹åˆ«æœ‰ç”¨ã€‚

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const stringToLength = z.string().pipe(z.transform(val => val.length));

stringToLength.parse("hello"); // => 5
```
</Tab>
<Tab value="Zod Mini">
```ts
const stringToLength = z.pipe(z.string(), z.transform(val => val.length));

z.parse(stringToLength, "hello"); // => 5
```
</Tab>
</Tabs>


## å˜æ¢ï¼ˆTransformsï¼‰

> **æ³¨æ„** â€” å¯¹äºåŒå‘è½¬æ¢ï¼Œè¯·ä½¿ç”¨ [codecs](/codecs)ã€‚

è½¬æ¢æ˜¯ä¸€ç§ç‰¹æ®Šçš„æ¨¡å¼ï¼Œæ‰§è¡Œå•å‘è½¬æ¢ã€‚å®ƒä»¬ä¸éªŒè¯è¾“å…¥ï¼Œè€Œæ˜¯æ¥å—ä»»ä½•å†…å®¹å¹¶å¯¹æ•°æ®è¿›è¡ŒæŸç§è½¬æ¢ã€‚è¦å®šä¹‰ä¸€ä¸ªè½¬æ¢ï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const castToString = z.transform((val) => String(val));

castToString.parse("asdf"); // => "asdf"
castToString.parse(123); // => "123"
castToString.parse(true); // => "true"
```
</Tab>
<Tab value="Zod Mini">
```ts
const castToString = z.transform((val) => String(val));

z.parse(castToString, "asdf"); // => "asdf"
z.parse(castToString, 123); // => "123"
z.parse(castToString, true); // => "true"
```
</Tab>
</Tabs>

<Callout type="warn">
  è½¬æ¢å‡½æ•°ä¸åº”æŠ›å‡ºå¼‚å¸¸ã€‚Zodä¸ä¼šæ•è·æŠ›å‡ºçš„é”™è¯¯ã€‚
</Callout>

{/* å˜æ¢æ¨¡å¼çš„è¾“å‡ºç±»å‹ç”±å˜æ¢å‡½æ•°æ¨æ–­ï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const castToString = z.transform((val) => String(val));

type CastToString = z.infer<typeof castToString>; // string
```
</Tab>
<Tab value="Zod Mini">
```ts
const castToString = z.transform((val) => String(val));

type CastToString = z.infer<typeof castToString>; // string
```
</Tab>
</Tabs> */}


åœ¨å˜æ¢ä¸­æ‰§è¡ŒéªŒè¯é€»è¾‘ï¼Œä½¿ç”¨ `ctx`ã€‚æ·»åŠ éªŒè¯é—®é¢˜ï¼Œæ¨å…¥ `ctx.issues`ï¼ˆç±»ä¼¼[`.check()`](#check) APIï¼‰ã€‚

```ts
const coercedInt = z.transform((val, ctx) => {
  try {
    const parsed = Number.parseInt(String(val));
    return parsed;
  } catch (e) {
    ctx.issues.push({
      code: "custom",
      message: "Not a number",
      input: val,
    });

    // è¿™æ˜¯ç±»å‹ä¸º `never` çš„ç‰¹æ®Šå¸¸é‡
    // è¿”å›å®ƒå¯é€€å‡ºå˜æ¢ä¸”ä¸å½±å“æ¨æ–­è¿”å›ç±»å‹
    return z.NEVER;
  }
});
```

å˜æ¢é€šå¸¸ä¸[ç®¡é“](#pipes)è”åˆä½¿ç”¨ã€‚æ­¤ç»„åˆæ–¹ä¾¿åœ¨æ‰§è¡Œåˆæ­¥éªŒè¯åï¼Œå°†è§£ææ•°æ®è½¬æ¢ä¸ºå¦ä¸€å½¢å¼ã€‚

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const stringToLength = z.string().pipe(z.transform(val => val.length));

stringToLength.parse("hello"); // => 5
```
</Tab>
<Tab value="Zod Mini">
```ts
const stringToLength = z.pipe(z.string(), z.transform(val => val.length));

z.parse(stringToLength, "hello"); // => 5
```
</Tab>
</Tabs>

### `.transform()`

å°†ç®¡é“è¾“å…¥è½¬æ¢ï¼Œå¸¸ç”¨æ¨¡å¼ï¼ŒZod æä¾› `.transform()` ä¾¿æ·æ–¹æ³•ã€‚

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const stringToLength = z.string().transform(val => val.length); 
```
</Tab>
<Tab value="Zod Mini">
```ts
// æ— å¯¹åº”åŠŸèƒ½
```
</Tab>
</Tabs>

å˜æ¢å¯å¼‚æ­¥ï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const idToUser = z
  .string()
  .transform(async (id) => {
    // ä»æ•°æ®åº“è·å–ç”¨æˆ·
    return db.getUserById(id); 
  });

const user = await idToUser.parseAsync("abc123");
```
</Tab>
<Tab value="Zod Mini">
```ts
const idToUser = z.pipe(
  z.string(),
  z.transform(async (id) => {
    // ä»æ•°æ®åº“è·å–ç”¨æˆ·
    return db.getUserById(id); 
  }));

const user = await idToUser.parse("abc123");
```
</Tab>
</Tabs>

<Callout>
  è‹¥ä½¿ç”¨å¼‚æ­¥å˜æ¢ï¼Œè§£ææ•°æ®æ—¶å¿…é¡»ç”¨ `.parseAsync` æˆ– `.safeParseAsync`ï¼Œå¦åˆ™ Zod ä¼šæŠ›é”™ã€‚
</Callout>

### `.preprocess()` 

å°†å˜æ¢ç®¡é“è‡³å¦ä¸€ä¸ªæ¨¡å¼ä¹Ÿå¸¸è§ï¼ŒZod æä¾› `z.preprocess()` ä¾¿æ·å‡½æ•°ã€‚

```ts
const coercedInt = z.preprocess((val) => {
  if (typeof val === "string") {
    return Number.parseInt(val);
  }
  return val;
}, z.int());
```

## é»˜è®¤å€¼

ä¸ºæ¨¡å¼è®¾ç½®é»˜è®¤å€¼ï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const defaultTuna = z.string().default("tuna");

defaultTuna.parse(undefined); // => "tuna"
```
</Tab>
<Tab value="Zod Mini">
```ts
const defaultTuna = z._default(z.string(), "tuna");

defaultTuna.parse(undefined); // => "tuna"
```
</Tab>
</Tabs>

ä¹Ÿå¯ä¼ å…¥å‡½æ•°ï¼Œæ¯æ¬¡éœ€ç”Ÿæˆé»˜è®¤å€¼æ—¶æ‰§è¡Œï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const randomDefault = z.number().default(Math.random);

randomDefault.parse(undefined);    // => 0.4413456736055323
randomDefault.parse(undefined);    // => 0.1871840107401901
randomDefault.parse(undefined);    // => 0.7223408162401552
```
</Tab>
<Tab value="Zod Mini">
```ts
const randomDefault = z._default(z.number(), Math.random);

z.parse(randomDefault, undefined); // => 0.4413456736055323
z.parse(randomDefault, undefined); // => 0.1871840107401901
z.parse(randomDefault, undefined); // => 0.7223408162401552
```
</Tab>
</Tabs>


## é¢„æ•…éšœå€¼ï¼ˆPrefaultsï¼‰

åœ¨ Zod ä¸­ï¼Œè®¾ç½®*é»˜è®¤å€¼*ä¼šçŸ­è·¯è§£æã€‚è‹¥è¾“å…¥ä¸º `undefined`ï¼Œä¼šç«‹å³è¿”å›é»˜è®¤å€¼ã€‚å› æ­¤é»˜è®¤å€¼å¿…é¡»èµ‹å€¼ç»™æ¨¡å¼çš„*è¾“å‡ºç±»å‹*ã€‚

```ts
const schema = z.string().transform(val => val.length).default(0);
schema.parse(undefined); // => 0
```

æœ‰æ—¶å®šä¹‰*é¢„æ•…éšœå€¼*ï¼ˆâ€œé¢„è§£æé»˜è®¤â€ï¼‰æ›´å®ç”¨ã€‚è‹¥è¾“å…¥ä¸º `undefined`ï¼Œå°†æ›¿ä»£æ€§åœ°å…ˆè§£æé¢„æ•…éšœå€¼ï¼Œè§£æè¿‡ç¨‹*ä¸*çŸ­è·¯ã€‚å› æ­¤ï¼Œé¢„æ•…éšœå€¼å¿…é¡»èµ‹å€¼ç»™æ¨¡å¼çš„*è¾“å…¥ç±»å‹*ã€‚

```ts
z.string().transform(val => val.length).prefault("tuna");
schema.parse(undefined); // => 4
```

è‹¥å¸Œæœ›åœ¨ä¸€äº›å˜å¼‚å‹ç²¾ç‚¼ä¸­ä½¿ç”¨è¾“å…¥å€¼ï¼Œæ­¤æ³•æœ‰ç”¨ã€‚

```ts
const a = z.string().trim().toUpperCase().prefault("  tuna  ");
a.parse(undefined); // => "TUNA"

const b = z.string().trim().toUpperCase().default("  tuna  ");
b.parse(undefined); // => "  tuna  "
```

## æ•è·å€¼ï¼ˆCatchï¼‰

ä½¿ç”¨ `.catch()` å®šä¹‰éªŒè¯é”™è¯¯æ—¶çš„å¤‡ç”¨å€¼ï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const numberWithCatch = z.number().catch(42);

numberWithCatch.parse(5); // => 5
numberWithCatch.parse("tuna"); // => 42
```
</Tab>
<Tab value="Zod Mini">
```ts
const numberWithCatch = z.catch(z.number(), 42);

numberWithCatch.parse(5); // => 5
numberWithCatch.parse("tuna"); // => 42
```
</Tab>
</Tabs>


æˆ–ä¼ å…¥å‡½æ•°ï¼Œæ¯æ¬¡ç”Ÿæˆæ•è·å€¼æ—¶æ‰§è¡Œ:

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const numberWithRandomCatch = z.number().catch((ctx) => {
  ctx.error; // æ•è·çš„ ZodError
  return Math.random();
});

numberWithRandomCatch.parse("sup"); // => 0.4413456736055323
numberWithRandomCatch.parse("sup"); // => 0.1871840107401901
numberWithRandomCatch.parse("sup"); // => 0.7223408162401552
```
</Tab>
<Tab value="Zod Mini">
```ts
const numberWithRandomCatch = z.catch(z.number(), (ctx) => {
  ctx.value;   // è¾“å…¥å€¼
  ctx.issues;  // æ•è·çš„éªŒè¯é—®é¢˜
  return Math.random();
});

z.parse(numberWithRandomCatch, "sup"); // => 0.4413456736055323
z.parse(numberWithRandomCatch, "sup"); // => 0.1871840107401901
z.parse(numberWithRandomCatch, "sup"); // => 0.7223408162401552
```
</Tab>
</Tabs>

## å“ç‰Œç±»å‹

TypeScript ç±»å‹ç³»ç»Ÿæ˜¯[ç»“æ„åŒ–](https://www.typescriptlang.org/docs/handbook/type-compatibility.html)çš„ï¼Œç»“æ„ç›¸åŒçš„ç±»å‹è¢«è§†ä¸ºç›¸åŒã€‚

```ts
type Cat = { name: string };
type Dog = { name: string };

const pluto: Dog = { name: "pluto" };
const simba: Cat = pluto; // works fine
```

æŸäº›æƒ…å†µä¸­ï¼Œæƒ³åœ¨ TypeScript å†…æ¨¡æ‹Ÿ[æ ‡ç§°ç±»å‹](https://en.wikipedia.org/wiki/Nominal_type_system)ï¼Œå¯ç”¨*å“ç‰Œç±»å‹*ï¼ˆåˆç§°â€œä¸é€æ˜ç±»å‹â€ï¼‰ã€‚

```ts
const Cat = z.object({ name: z.string() }).brand<"Cat">();
const Dog = z.object({ name: z.string() }).brand<"Dog">();

type Cat = z.infer<typeof Cat>; // { name: string } & z.$brand<"Cat">
type Dog = z.infer<typeof Dog>; // { name: string } & z.$brand<"Dog">

const pluto = Dog.parse({ name: "pluto" });
const simba: Cat = pluto; // âŒ ä¸å…è®¸
```

å…¶åŸç†æ˜¯ä¸ºæ¨¡å¼æ¨æ–­ç±»å‹é™„åŠ â€œå“ç‰Œâ€ã€‚

```ts
const Cat = z.object({ name: z.string() }).brand<"Cat">();
type Cat = z.output<typeof Cat>; // { name: string } & z.$brand<"Cat">
```

ä½¿ç”¨æ­¤å“ç‰Œåï¼Œä»»ä½•æ™®é€šï¼ˆæ— å“ç‰Œï¼‰æ•°æ®ç»“æ„éƒ½ä¸å†å¯åˆ†é…ç»™æ¨æ–­ç±»å‹ã€‚ä½ å¿…é¡»ä½¿ç”¨æ¨¡å¼è§£æä¸€äº›æ•°æ®ï¼Œä»¥è·å¾—å¸¦å“ç‰Œçš„æ•°æ®ã€‚

> è¯·æ³¨æ„ï¼Œå“ç‰Œç±»å‹ä¸ä¼šå½±å“ `.parse` çš„è¿è¡Œæ—¶ç»“æœã€‚å®ƒåªæ˜¯ä¸€ä¸ªä»…ç”¨äºé™æ€çš„ç»“æ„ã€‚

é»˜è®¤æƒ…å†µä¸‹ï¼Œåªæœ‰*è¾“å‡ºç±»å‹*æ˜¯å¸¦å“ç‰Œçš„ã€‚

```ts
const USD = z.string().brand<"USD">();

type USDOutput = z.output<typeof USD>; // string & z.$brand<"USD">
type USDInput = z.input<typeof USD>; // string
```

è¦è‡ªå®šä¹‰æ­¤é¡¹ï¼Œè¯·å‘ `.brand()` ä¼ é€’ç¬¬äºŒä¸ªæ³›å‹ä»¥æŒ‡å®šå“ç‰Œçš„æ–¹å‘ã€‚

```ts
// requires Zod 4.2+
z.string().brand<"Cat", "in">(); // output is branded (default)
z.string().brand<"Cat", "out">(); // input is branded
z.string().brand<"Cat", "inout">(); // both are branded
```

## åªè¯»

ä½¿æ¨¡å¼åªè¯»ï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const ReadonlyUser = z.object({ name: z.string() }).readonly();
type ReadonlyUser = z.infer<typeof ReadonlyUser>;
// Readonly<{ name: string }>
```
</Tab>
<Tab value="Zod Mini">
```ts
const ReadonlyUser = z.readonly(z.object({ name: z.string() }));
type ReadonlyUser = z.infer<typeof ReadonlyUser>;
// Readonly<{ name: string }>
```
</Tab>
</Tabs>

æ–°æ¨¡å¼æ¨æ–­ç±»å‹ä¼šæ ‡è®°ä¸º `readonly`ã€‚æ³¨æ„ï¼Œåœ¨ TypeScript ä¸­ï¼Œè¿™åªå½±å“å¯¹è±¡ã€æ•°ç»„ã€å…ƒç»„ã€`Set` å’Œ `Map`ï¼š

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
z.object({ name: z.string() }).readonly(); // { readonly name: string }
z.array(z.string()).readonly(); // readonly string[]
z.tuple([z.string(), z.number()]).readonly(); // readonly [string, number]
z.map(z.string(), z.date()).readonly(); // ReadonlyMap<string, Date>
z.set(z.string()).readonly(); // ReadonlySet<string>
```
</Tab>
<Tab value="Zod Mini">
```ts
z.readonly(z.object({ name: z.string() })); // { readonly name: string }
z.readonly(z.array(z.string())); // readonly string[]
z.readonly(z.tuple([z.string(), z.number()])); // readonly [string, number]
z.readonly(z.map(z.string(), z.date())); // ReadonlyMap<string, Date>
z.readonly(z.set(z.string())); // ReadonlySet<string>
```
</Tab>
</Tabs>

è¾“å…¥ä¼šåƒå¾€å¸¸ä¸€æ ·è¢«è§£æï¼Œç»“æœä½¿ç”¨ [`Object.freeze()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze) å†»ç»“ï¼Œé˜²æ­¢ä¿®æ”¹ã€‚

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const result = ReadonlyUser.parse({ name: "fido" });
result.name = "simba"; // æŠ›å‡º TypeError
```
</Tab>
<Tab value="Zod Mini">
```ts
const result = z.parse(ReadonlyUser, { name: "fido" });
result.name = "simba"; // æŠ›å‡º TypeError
```
</Tab>
</Tabs>

## JSON

éªŒè¯ä»»æ„ JSON å¯ç¼–ç å€¼ï¼š

```ts
const jsonSchema = z.json();
```

æ­¤ä¸ºä¾¿æ· APIï¼Œè¿”å›å¦‚ä¸‹è”åˆæ¨¡å¼ï¼š

```ts
const jsonSchema = z.lazy(() => {
  return z.union([
    z.string(params), 
    z.number(), 
    z.boolean(), 
    z.null(), 
    z.array(jsonSchema), 
    z.record(z.string(), jsonSchema)
  ]);
});
```



## å‡½æ•°

Zod æä¾› `z.function()` å·¥å…·å®šä¹‰ç»è¿‡ Zod éªŒè¯çš„å‡½æ•°ã€‚é¿å…éªŒè¯ç æ··å…¥ä¸šåŠ¡é€»è¾‘ã€‚

```ts
const MyFunction = z.function({
  input: [z.string()], // å‚æ•°ï¼ˆå¿…é¡»ä¸ºæ•°ç»„æˆ– ZodTupleï¼‰
  output: z.number()  // è¿”å›å€¼ç±»å‹
});

type MyFunction = z.infer<typeof MyFunction>;
// (input: string) => number
```

å‡½æ•°æ¨¡å¼æ‹¥æœ‰ `.implement()` æ–¹æ³•ï¼Œæ¥å—å‡½æ•°ï¼Œè¿”å›è‡ªåŠ¨éªŒè¯è¾“å…¥è¾“å‡ºçš„æ–°å‡½æ•°ã€‚

```ts
const computeTrimmedLength = MyFunction.implement((input) => {
  // TypeScript è¯†åˆ« input ä¸º stringï¼
  return input.trim().length;
});

computeTrimmedLength("sandwich"); // => 8
computeTrimmedLength(" asdf "); // => 4
```

è¾“å…¥éªŒè¯å¤±è´¥æ—¶æŠ› `ZodError`ï¼š

```ts
computeTrimmedLength(42); // æŠ›å‡º ZodError
```

è‹¥åªå…³å¿ƒéªŒè¯è¾“å…¥ï¼Œå¯çœç•¥ `output` å­—æ®µã€‚

```ts
const MyFunction = z.function({
  input: [z.string()], // å‚æ•°ï¼ˆå¿…é¡»æ˜¯æ•°ç»„æˆ– ZodTupleï¼‰
});

const computeTrimmedLength = MyFunction.implement((input) => input.trim.length);
```


ä½¿ç”¨ `.implementAsync()` æ–¹æ³•åˆ›å»ºä¸€ä¸ªå¼‚æ­¥å‡½æ•°ã€‚

```ts
const computeTrimmedLengthAsync = MyFunction.implementAsync(
  async (input) => input.trim().length
);

computeTrimmedLengthAsync("sandwich"); // => Promise<8>
```

## è‡ªå®šä¹‰

æ‚¨å¯ä»¥é€šè¿‡ä½¿ç”¨ `z.custom()` ä¸ºä»»ä½• TypeScript ç±»å‹åˆ›å»º Zod æ¨¡å¼ã€‚è¿™å¯¹äºä¸º Zod é»˜è®¤ä¸æ”¯æŒçš„ç±»å‹ï¼ˆä¾‹å¦‚æ¨¡æ¿å­—ç¬¦ä¸²å­—é¢é‡ï¼‰åˆ›å»ºæ¨¡å¼éå¸¸æœ‰ç”¨ã€‚

```ts
const px = z.custom<`${number}px`>((val) => {
  return typeof val === "string" ? /^\d+px$/.test(val) : false;
});

type px = z.infer<typeof px>; // `${number}px`

px.parse("42px"); // "42px"
px.parse("42vw"); // throws;
```

å¦‚æœæ‚¨ä¸æä¾›éªŒè¯å‡½æ•°ï¼ŒZod å°†å…è®¸ä»»ä½•å€¼ã€‚è¿™å¯èƒ½æ˜¯å±é™©çš„ï¼

```ts
z.custom<{ arg: string }>(); // performs no validation
```

æ‚¨å¯ä»¥é€šè¿‡ä¼ é€’ç¬¬äºŒä¸ªå‚æ•°æ¥è‡ªå®šä¹‰é”™è¯¯æ¶ˆæ¯å’Œå…¶ä»–é€‰é¡¹ã€‚æ­¤å‚æ•°çš„å·¥ä½œæ–¹å¼ä¸ [`.refine`](#refine) çš„ params å‚æ•°ç›¸åŒã€‚

```ts
z.custom<...>((val) => ..., "custom error message");
```
