---
title: 定义模式
---

import { Tabs, Tab } from 'fumadocs-ui/components/tabs';
import { Callout } from "fumadocs-ui/components/callout"
import { Accordion, Accordions } from 'fumadocs-ui/components/accordion';

要验证数据，您必须首先定义一个*模式*。模式代表*类型*，从简单的原始值到复杂的嵌套对象和数组。

## 原始类型

```ts
import * as z from "zod/v4";

// 原始类型
z.string();
z.number();
z.bigint();
z.boolean();
z.symbol();
z.undefined();
z.null();
```


### 强制转换

若要将输入数据强制转换为适当的类型，请改用 `z.coerce`：

```ts
z.coerce.string();    // String(input)
z.coerce.number();    // Number(input)
z.coerce.boolean();   // Boolean(input)
z.coerce.bigint();    // BigInt(input)
```

这些模式的强制转换版本尝试将输入值转换为适合的类型。

```ts
const schema = z.coerce.string();

schema.parse("tuna");    // => "tuna"
schema.parse(42);        // => "42"
schema.parse(true);      // => "true"
schema.parse(null);      // => "null"
```

<Accordions type="single"><Accordion title="Zod 中的强制转换原理">
  
  Zod 使用内置构造函数对所有输入执行强制转换。

  | Zod API                  | 强制转换                   |
  |--------------------------|----------------------------|
  | `z.coerce.string()`      | `String(value)`            |
  | `z.coerce.number()`      | `Number(value)`            |
  | `z.coerce.boolean()`     | `Boolean(value)`           |
  | `z.coerce.bigint()`      | `BigInt(value)`            |
  | `z.coerce.date()`        | `new Date(value)`          |

  使用 `z.coerce.boolean()` 进行布尔强制转换可能不会像您预期的那样工作。任何[真值](https://developer.mozilla.org/en-US/docs/Glossary/Truthy)都被强制转换为 `true`，而任何[假值](https://developer.mozilla.org/en-US/docs/Glossary/Falsy)都被强制转换为 `false`。

  ```ts
  const schema = z.coerce.boolean(); // Boolean(input)

  schema.parse("tuna"); // => true
  schema.parse("true"); // => true
  schema.parse("false"); // => true
  schema.parse(1); // => true
  schema.parse([]); // => true

  schema.parse(0); // => false
  schema.parse(""); // => false
  schema.parse(undefined); // => false
  schema.parse(null); // => false
  ```

  若要完全控制强制转换逻辑，考虑使用 [`z.transform()`](#transforms) 或 [`z.pipe()`](#pipes)。

</Accordion></Accordions>


## 字面量

字面量模式代表[字面量类型](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types)，例如 `"hello world"` 或 `5`。

```ts
const tuna = z.literal("tuna");
const twelve = z.literal(12);
const twobig = z.literal(2n);
const tru = z.literal(true);
```

表示 JavaScript 字面量 `null` 和 `undefined`：

```ts
z.null();
z.undefined();
z.void(); // 等价于 z.undefined()
```

允许多个字面量值：

```ts
const colors = z.literal(["red", "green", "blue"]);

colors.parse("green"); // ✅
colors.parse("yellow"); // ❌
```

从字面量模式中提取允许值集合：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]} persist>
<Tab value="Zod">
```ts
colors.values; // => Set<"red" | "green" | "blue">
```
</Tab>
<Tab value="Zod Mini">
```ts
// 无对应功能
```
</Tab>
</Tabs>



## 字符串

{/* Zod 提供了若干内置的字符串验证和转换 API。

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
z.string().startsWith("fourscore")
```
</Tab>
<Tab value="Zod Mini">
```ts zod/v4-mini
z.string().check(z.startsWith("fourscore"))
```
</Tab>
</Tabs>

以下所有 API 均支持 `error` 参数来自定义错误消息。

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
z.string().startsWith("fourscore", {error: "Nice try, buddy"})
```
</Tab>
<Tab value="Zod Mini">
```ts zod/v4-mini
z.string().check(z.startsWith("fourscore", {error: "Nice try, buddy"}))
```
</Tab></Tabs> */}


Zod 提供了一些内置的字符串验证和转换 API。执行常见字符串验证：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
z.string().max(5);
z.string().min(5);
z.string().length(5);
z.string().regex(/^[a-z]+$/);
z.string().startsWith("aaa");
z.string().endsWith("zzz");
z.string().includes("---");
z.string().uppercase();
z.string().lowercase();
```
</Tab>
<Tab value="Zod Mini">
```ts zod/v4-mini
z.string().check(z.maxLength(5));
z.string().check(z.minLength(5));
z.string().check(z.length(5));
z.string().check(z.regex(/^[a-z]+$/));
z.string().check(z.startsWith("aaa"));
z.string().check(z.endsWith("zzz"));
z.string().check(z.includes("---"));
z.string().check(z.uppercase());
z.string().check(z.lowercase());
```
</Tab>
</Tabs>

执行简单的字符串转换：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
z.string().trim(); // 去除空白
z.string().toLowerCase(); // 转小写
z.string().toUpperCase(); // 转大写
```
</Tab>
<Tab value="Zod Mini">
```ts zod/v4-mini
z.string().check(z.trim()); // 去除空白
z.string().check(z.toLowerCase()); // 转小写
z.string().check(z.toUpperCase()); // 转大写
```
</Tab>
</Tabs>

## 字符串格式

验证常见字符串格式：

```ts
z.email();
z.uuid();
z.url();
z.emoji();         // 验证单个 emoji 字符
z.base64();
z.base64url();
z.nanoid();
z.cuid();
z.cuid2();
z.ulid();
z.ipv4();
z.ipv6();
z.cidrv4();        // ipv4 CIDR 块
z.cidrv6();        // ipv6 CIDR 块
z.iso.date();
z.iso.time();
z.iso.datetime();
z.iso.duration();
```

### 邮件

验证邮箱地址：

```ts
z.email();
```

默认情况下，Zod 使用一种相对严格的邮箱正则表达式，设计用来验证包含常见字符的普通邮箱地址。大致相当于 Gmail 采用的规则。欲了解更多，参考[这篇文章](https://colinhacks.com/essays/reasonable-email-regex)。

```ts
/^(?!\.)(?!.*\.\.)([a-z0-9_'+\-\.]*)[a-z0-9_+-]@([a-z0-9][a-z0-9\-]*\.)+[a-z]{2,}$/i
```

要自定义邮箱验证行为，可以向 `pattern` 参数传递一个自定义正则表达式。

```ts
z.email({ pattern: /your regex here/ });
```

Zod 导出了一些实用的正则表达式可供使用。

```ts
// Zod 默认邮箱正则
z.email();
z.email({ pattern: z.regexes.email }); // 等价

// 浏览器用于 input[type=email] 字段的正则
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/email
z.email({ pattern: z.regexes.html5Email });

// 经典 emailregex.com 正则 (RFC 5322)
z.email({ pattern: z.regexes.rfc5322Email });

// 一个允许 Unicode 的宽松正则 (适用于国际邮箱)
z.email({ pattern: z.regexes.unicodeEmail });
```

### UUID

验证 UUID：

```ts
z.uuid();
```

指定特定 UUID 版本：

```ts
// 支持 "v1", "v2", "v3", "v4", "v5", "v6", "v7", "v8"
z.uuid({ version: "v4" });

// 方便形式
z.uuidv4();
z.uuidv6();
z.uuidv7();
```

RFC 4122 UUID 规范要求字节 8 的前两位为 `10`，其他 UUID-like 标识符不强制该限制。验证任意 UUID-like 标识符：

```ts
z.guid();
```

### URL

验证任意 WHATWG 兼容 URL：

```ts
const schema = z.url();

schema.parse("https://example.com"); // ✅
schema.parse("http://localhost"); // ✅
schema.parse("mailto:noreply@zod.dev"); // ✅
schema.parse("sup"); // ✅
```

如您所见，这非常宽松。内部使用 `new URL()` 构造函数验证输入；此行为可能因平台和运行时而异，但这是在任何 JS 运行时/引擎上验证 URI/URL 的最严谨方法。

验证主机名是否匹配特定正则：

```ts
const schema = z.url({ hostname: /^example\.com$/ });

schema.parse("https://example.com"); // ✅
schema.parse("https://zombo.com"); // ❌
```

要验证协议是否匹配特定正则，使用 `protocol` 参数。

```ts
const schema = z.url({ protocol: /^https$/ });

schema.parse("https://example.com"); // ✅
schema.parse("http://example.com"); // ❌
```

<Callout>
  **Web URLs** — 许多情况下，您可能只想验证 Web URL。推荐的模式如下：

  ```ts
  const httpUrl = z.url({
    protocol: /^https?$/,
    hostname: z.regexes.domain
  });
  ```

  该配置限定协议为 `http`/`https`，并通过 `z.regexes.domain` 正则确保主机名为合法域名：

  ```ts
  /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/
  ```
</Callout>

### ISO 日期时间

您可能注意到，Zod 字符串包含一些日期/时间相关的验证。这些是基于正则表达式的，因此不如完整的日期/时间库严格，但非常方便验证用户输入。

`z.iso.datetime()` 方法强制 ISO 8601 格式；默认不允许时区偏移：

```ts
const datetime = z.iso.datetime();

datetime.parse("2020-01-01T06:15:00Z"); // ✅
datetime.parse("2020-01-01T06:15:00.123Z"); // ✅
datetime.parse("2020-01-01T06:15:00.123456Z"); // ✅ (arbitrary precision)
datetime.parse("2020-01-01T06:15:00+02:00"); // ❌ (offsets not allowed)
datetime.parse("2020-01-01T06:15:00"); // ❌ (local not allowed)
```

允许时区偏移：

```ts
const datetime = z.iso.datetime({ offset: true });

// allows timezone offsets
datetime.parse("2020-01-01T06:15:00+02:00"); // ✅

// basic offsets not allowed
datetime.parse("2020-01-01T06:15:00+02");    // ❌
datetime.parse("2020-01-01T06:15:00+0200");  // ❌

// Z is still supported
datetime.parse("2020-01-01T06:15:00Z"); // ✅ 
```

允许无时区（本地）日期时间：

```ts
const schema = z.iso.datetime({ local: true });
schema.parse("2020-01-01T06:15:01"); // ✅
schema.parse("2020-01-01T06:15"); // ✅ seconds optional
```

限制允许的时间 `precision`。默认情况下，秒数为可选且允许任意亚秒级精度。

```ts
const a = z.iso.datetime();
a.parse("2020-01-01T06:15Z"); // ✅
a.parse("2020-01-01T06:15:00Z"); // ✅
a.parse("2020-01-01T06:15:00.123Z"); // ✅

const b = z.iso.datetime({ precision: -1 }); // minute precision (no seconds)
b.parse("2020-01-01T06:15Z"); // ✅
b.parse("2020-01-01T06:15:00Z"); // ❌
b.parse("2020-01-01T06:15:00.123Z"); // ❌

const c = z.iso.datetime({ precision: 0 }); // second precision only
c.parse("2020-01-01T06:15Z"); // ❌
c.parse("2020-01-01T06:15:00Z"); // ✅
c.parse("2020-01-01T06:15:00.123Z"); // ❌

const d = z.iso.datetime({ precision: 3 }); // millisecond precision only
d.parse("2020-01-01T06:15Z"); // ❌
d.parse("2020-01-01T06:15:00Z"); // ❌
d.parse("2020-01-01T06:15:00.123Z"); // ✅
```

### ISO 日期

`z.iso.date()` 方法验证格式为 `YYYY-MM-DD` 的字符串。

```ts
const date = z.iso.date();

date.parse("2020-01-01"); // ✅
date.parse("2020-1-1"); // ❌
date.parse("2020-01-32"); // ❌
```

### ISO 时间

`z.iso.time()` 方法验证格式为 `HH:MM[:SS[.s+]]` 的字符串。默认情况下，秒是可选的，亚秒的小数部分也是可选的。

```ts
const time = z.iso.time();

time.parse("03:15"); // ✅
time.parse("03:15:00"); // ✅
time.parse("03:15:00.9999999"); // ✅ (arbitrary precision)
```

不允许任何形式的抵消。

```ts
time.parse("03:15:00Z"); // ❌ (no `Z` allowed)
time.parse("03:15:00+02:00"); // ❌ (no offsets allowed)
```

使用 `precision` 参数来限制允许的小数精度。

```ts
z.iso.time({ precision: -1 }); // HH:MM (minute precision)
z.iso.time({ precision: 0 }); // HH:MM:SS (second precision)
z.iso.time({ precision: 1 }); // HH:MM:SS.s (decisecond precision)
z.iso.time({ precision: 2 }); // HH:MM:SS.ss (centisecond precision)
z.iso.time({ precision: 3 }); // HH:MM:SS.sss (millisecond precision)
```

### IP 地址

```ts
const ipv4 = z.ipv4();
ipv4.parse("192.168.0.0"); // ✅

const ipv6 = z.ipv6();
ipv6.parse("2001:db8:85a3::8a2e:370:7334"); // ✅
```

### IP 块 (CIDR)

验证使用[CIDR 表示法](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)的 IP 地址段。

```ts
const cidrv4 = z.string().cidrv4();
cidrv4.parse("192.168.0.0/24"); // ✅

const cidrv6 = z.string().cidrv6();
cidrv6.parse("2001:db8::/32"); // ✅
```

## 模板字面量

> **Zod 4 新增**

定义模板字面量模式：

```ts
const schema = z.templateLiteral([ "hello, ", z.string(), "!" ]);
// `hello, ${string}!`
```

`z.templateLiteral` API 可以处理任意数量的字符串字面量（如 `"hello"`）和模式。可传入任何推断类型可赋值给`string | number | bigint | boolean | null | undefined`的模式。

```ts
z.templateLiteral([ "hi there" ]);
// `hi there`

z.templateLiteral([ "email: ", z.string() ]);
// `email: ${string}`

z.templateLiteral([ "high", z.literal(5) ]);
// `high5`

z.templateLiteral([ z.nullable(z.literal("grassy")) ]);
// `grassy` | `null`

z.templateLiteral([ z.number(), z.enum(["px", "em", "rem"]) ]);
// `${number}px` | `${number}em` | `${number}rem`
```

## 数字

使用 `z.number()` 验证数字。允许所有有限数字。

```ts
const schema = z.number();

schema.parse(3.14);      // ✅
schema.parse(NaN);       // ❌
schema.parse(Infinity);  // ❌
```

Zod 实现了若干特定数字的验证：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
z.number().gt(5);
z.number().gte(5);                     // 同 .min(5)
z.number().lt(5);
z.number().lte(5);                     // 同 .max(5)
z.number().positive();       
z.number().nonnegative();    
z.number().negative(); 
z.number().nonpositive(); 
z.number().multipleOf(5);              // 同 .step(5)
```
</Tab>
<Tab value="Zod Mini">
```ts zod/v4-mini
z.number().check(z.gt(5));
z.number().check(z.gte(5));            // 同 .minimum(5)
z.number().check(z.lt(5));
z.number().check(z.lte(5));            // 同 .maximum(5)
z.number().check(z.positive()); 
z.number().check(z.nonnegative()); 
z.number().check(z.negative()); 
z.number().check(z.nonpositive()); 
z.number().check(z.multipleOf(5));     // 同 .step(5)
```
</Tab>
</Tabs>

如果（因某些原因）想验证 `NaN`，使用 `z.nan()`。

```ts
z.nan().parse(NaN);              // ✅
z.nan().parse("anything else");  // ❌
```

## 整数

验证整数：

```ts
z.int();     // 限制在安全整数范围
z.int32();   // 限制在 int32 范围
```

## BigInt

验证 BigInts：

```ts
z.bigint();
```

Zod 提供了一些针对 bigint 的验证。

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
z.bigint().gt(5n);
z.bigint().gte(5n);                    // 同 `.min(5n)`
z.bigint().lt(5n);
z.bigint().lte(5n);                    // 同 `.max(5n)`
z.bigint().positive(); 
z.bigint().nonnegative(); 
z.bigint().negative(); 
z.bigint().nonpositive(); 
z.bigint().multipleOf(5n);             // 同 `.step(5n)`
```
</Tab>
<Tab value="Zod Mini">
```ts zod/v4-mini
z.bigint().check(z.gt(5n));
z.bigint().check(z.gte(5n));           // 同 `.minimum(5n)`
z.bigint().check(z.lt(5n));
z.bigint().check(z.lte(5n));           // 同 `.maximum(5n)`
z.bigint().check(z.positive()); 
z.bigint().check(z.nonnegative()); 
z.bigint().check(z.negative()); 
z.bigint().check(z.nonpositive()); 
z.bigint().check(z.multipleOf(5n));    // 同 `.step(5n)`
```

</Tab>
</Tabs>

## 布尔值

验证布尔值：

```ts
z.boolean().parse(true); // => true
z.boolean().parse(false); // => false
```

## 日期

使用 `z.date()` 验证 `Date` 实例。

```ts
z.date().safeParse(new Date()); // success: true
z.date().safeParse("2022-01-12T06:15:00.000Z"); // success: false
```

自定义错误消息：

```ts
z.date({
  error: issue => issue.input === undefined ? "Required" : "Invalid date"
});
```

Zod 提供了一些针对日期的验证。

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
z.date().min(new Date("1900-01-01"), { error: "Too old!" });
z.date().max(new Date(), { error: "Too young!" });
```
</Tab>
<Tab value="Zod Mini">
```ts zod/v4-mini
z.date().check(z.minimum(new Date("1900-01-01"), { error: "Too old!" }));
z.date().check(z.maximum(new Date(), { error: "Too young!" }));
```
</Tab>
</Tabs>

<div id="zod-enums" style={{height:"0px" }} /> 

## 枚举

使用 `z.enum` 验证输入是否属于固定的允许字符串集合。

```ts
const FishEnum = z.enum(["Salmon", "Tuna", "Trout"]);

FishEnum.parse("Salmon"); // => "Salmon"
FishEnum.parse("Swordfish"); // => ❌
```

<Callout>
  注意 — 如果将字符串数组定义为变量，Zod 将无法正确推断各元素的精确值。

  ```ts
  const fish = ["Salmon", "Tuna", "Trout"];
  
  const FishEnum = z.enum(fish);
  type FishEnum = z.infer<typeof FishEnum>; // string
  ```

  解决方法是，始终直接将数组传入 `z.enum()`，或使用 [`as const`](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions)。

  ```ts
  const fish = ["Salmon", "Tuna", "Trout"] as const;

  const FishEnum = z.enum(fish);
  type FishEnum = z.infer<typeof FishEnum>; // "Salmon" | "Tuna" | "Trout"
  ```
</Callout>

您也可以传入外部声明的 TypeScript 枚举。

<Callout>
**Zod 4** — 这取代了 Zod 3 中的 `z.nativeEnum()` API。

请注意，使用 TypeScript 的 `enum` 关键字[并不推荐](https://www.totaltypescript.com/why-i-dont-like-typescript-enums)。
</Callout>

```ts
enum Fish {
  Salmon = "Salmon",
  Tuna = "Tuna",
  Trout = "Trout",
}

const FishEnum = z.enum(Fish);
```

### `.enum`

提取模式的值为类似枚举的对象：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const FishEnum = z.enum(["Salmon", "Tuna", "Trout"]);

FishEnum.enum;
// => { Salmon: "Salmon", Tuna: "Tuna", Trout: "Trout" }
```
</Tab>
<Tab value="Zod Mini">
```ts zod/v4-mini
const FishEnum = z.enum(["Salmon", "Tuna", "Trout"]);

FishEnum.def.entries;
// => { Salmon: "Salmon", Tuna: "Tuna", Trout: "Trout" }
```
</Tab>
</Tabs>

### `.exclude()`

创建新枚举模式，排除指定值：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const FishEnum = z.enum(["Salmon", "Tuna", "Trout"]);
const TunaOnly = FishEnum.exclude(["Salmon", "Trout"]);
```
</Tab>
<Tab value="Zod Mini">
```ts zod/v4-mini
// 无对应功能
 
```
</Tab>
</Tabs>

### `.extract()`

创建新枚举模式，仅包含指定值：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const FishEnum = z.enum(["Salmon", "Tuna", "Trout"]);
const SalmonAndTroutOnly = FishEnum.extract(["Salmon", "Trout"]);
```
</Tab>
<Tab value="Zod Mini">
```ts zod/v4-mini
// 无对应功能
 
```
</Tab>
</Tabs>

## 字符串布尔值 [#stringbool]

> **💎 Zod 4 新增**

某些情况下（如解析环境变量），将某些字符串“布尔值”解析为纯 `boolean` 值非常有用。为支持此功能，Zod 4 引入了 `z.stringbool()`：

```ts
const strbool = z.stringbool();

strbool.parse("true")         // => true
strbool.parse("1")            // => true
strbool.parse("yes")          // => true
strbool.parse("on")           // => true
strbool.parse("y")            // => true
strbool.parse("enabled")      // => true

strbool.parse("false");       // => false
strbool.parse("0");           // => false
strbool.parse("no");          // => false
strbool.parse("off");         // => false
strbool.parse("n");           // => false
strbool.parse("disabled");    // => false

strbool.parse(/* 其他任何值 */); // ZodError<[{ code: "invalid_value" }]>
```

自定义真值和假值：

```ts
// 这是默认值
z.stringbool({
  truthy: ["true", "1", "yes", "on", "y", "enabled"],
  falsy: ["false", "0", "no", "off", "n", "disabled"],
});
```

默认模式是*不区分大小写*的；所有输入先转换为小写，再与 `truthy` / `falsy` 比较。若要区分大小写：

```ts
z.stringbool({
  case: "sensitive"
});
```


## 可选

使模式*可选*（即允许 `undefined` 输入）。

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
z.optional(z.literal("yoda")); // 或 z.literal("yoda").optional()
```
</Tab>
<Tab value="Zod Mini">
```ts zod/v4-mini
z.optional(z.literal("yoda"));
```
</Tab>
</Tabs>

返回一个 `ZodOptional` 实例，包装了原模式。提取内层模式：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
optionalYoda.unwrap(); // ZodLiteral<"yoda">
```
</Tab>
<Tab value="Zod Mini">
```ts zod/v4-mini
optionalYoda.def.innerType; // ZodMiniLiteral<"yoda">
```
</Tab>
</Tabs>

## 可空

使模式*可空*（即允许 `null` 输入）。

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
z.nullable(z.literal("yoda")); // 或 z.literal("yoda").nullable()
```
</Tab>
<Tab value="Zod Mini">
```ts zod/v4-mini
const nullableYoda = z.nullable(z.literal("yoda"));
```
</Tab>
</Tabs>

返回一个 `ZodNullable` 实例，包装了原模式。提取内层模式：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
nullableYoda.unwrap(); // ZodLiteral<"yoda">
```
</Tab>
<Tab value="Zod Mini">
```ts zod/v4-mini
nullableYoda.def.innerType; // ZodMiniLiteral<"yoda">
```
</Tab>
</Tabs>

## Nullish

使模式*nullish*（即可选且可空）：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const nullishYoda = z.nullish(z.literal("yoda"));
```
</Tab>
<Tab value="Zod Mini">
```ts zod/v4-mini
const nullishYoda = z.nullish(z.literal("yoda"));
```
</Tab>
</Tabs>

更多关于[nullish](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#nullish-coalescing)概念，请参阅 TypeScript 手册。

## Unknown

Zod 致力于与 TypeScript 类型系统一一对应，因此提供以下特殊类型的 API：

```ts
// 允许任意值
z.any(); // 推断类型：`any`
z.unknown(); // 推断类型：`unknown`
```

## Never

没有任何值可以通过验证。

```ts
z.never(); // 推断类型：`never`
```

## 对象

定义对象类型：

```ts z.object
  // 所有属性默认必需
  const Person = z.object({
    name: z.string(),
    age: z.number(),
  });

  type Person = z.infer<typeof Person>;
  // => { name: string; age: number; }
  ```
默认所有属性必需。使某些属性可选：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts z.object
const Dog = z.object({
  name: z.string(),
  age: z.number().optional(),
});

Dog.parse({ name: "Yeller" }); // ✅
```
</Tab>
<Tab value="Zod Mini">
```ts z.object
const Dog = z.object({
  name: z.string(),
  age: z.optional(z.number())
});

Dog.parse({ name: "Yeller" }); // ✅
```
</Tab>
</Tabs>



默认情况下，未识别的键会从解析结果中*剥除*：

```ts z.object
Dog.parse({ name: "Yeller", extraKey: true });
// => { name: "Yeller" }
```

### `z.strictObject`

定义*严格*模式，检测到未知键时报错：

```ts z.object
const StrictDog = z.strictObject({
  name: z.string(),
});

StrictDog.parse({ name: "Yeller", extraKey: true });
// ❌ 抛出错误
```

### `z.looseObject`

定义*宽松*模式，允许未知键通过：

```ts z.object
const LooseDog = z.looseObject({
  name: z.string(),
});

Dog.parse({ name: "Yeller", extraKey: true });
// => { name: "Yeller", extraKey: true }
```

### `.catchall()`

定义*catchall*模式，验证所有未识别的键：



<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts z.object
const DogWithStrings = z.object({
  name: z.string(),
  age: z.number().optional(),
}).catchall(z.string());

DogWithStrings.parse({ name: "Yeller", extraKey: "extraValue" }); // ✅
DogWithStrings.parse({ name: "Yeller", extraKey: 42 }); // ❌
```
</Tab>
<Tab value="Zod Mini">
```ts z.object
const DogWithStrings = z.catchall(
  z.object({
    name: z.string(),
    age: z.number().optional(),
  }),
  z.string()
);

DogWithStrings.parse({ name: "Yeller", extraKey: "extraValue" }); // ✅
DogWithStrings.parse({ name: "Yeller", extraKey: 42 }); // ❌
```
</Tab>
</Tabs>


### `.shape`

访问内部模式：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
Dog.shape.name; // => string schema
Dog.shape.age; // => number schema
```
</Tab>
<Tab value="Zod Mini">
```ts zod/v4-mini
Dog.def.shape.name; // => string schema
Dog.def.shape.age; // => number schema
```
</Tab>
</Tabs>

### `.keyof()`

从对象模式的键创建 `ZodEnum` 模式：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const keySchema = Dog.keyof();
// => ZodEnum<["name", "age"]>
```
</Tab>
<Tab value="Zod Mini">
```ts zod/v4-mini
const keySchema = z.keyof(Dog);
// => ZodEnum<["name", "age"]>
```
</Tab>
</Tabs>

### `.extend()`

为对象模式添加额外字段：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const DogWithBreed = Dog.extend({
  breed: z.string(),
});
```
</Tab>
<Tab value="Zod Mini">
```ts zod/v4-mini
const DogWithBreed = z.extend(Dog, {
  breed: z.string(),
});
```
</Tab>
</Tabs>

<Callout>
  此 API 可用于覆盖已存在字段！请慎用此功能！若两个模式共享键，B 会覆盖 A。
</Callout>

虽然存在 `.extend` API，但推荐的扩展对象模式的方式是使用原模式的 `shape` 属性创建全新模式。

```ts
const DogWithBreed = z.object({
  ...Dog.shape,
  breed: z.string(),
});
```

这种方法干净且功能强大，具有多重优势：

1. 使用语言级特性（[解构赋值语法](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring)），非库特有 API
2. 适用于 Zod 和 Zod Mini，无需方法支持
3. 更加高效 —— `.extend()` 在大模式上计算量大，且因[TypeScript 限制](https://github.com/microsoft/TypeScript/pull/61505)，链式调用时复杂度平方级增长
4. 可通过 `z.strictObject()` 或 `z.looseObject()` 调整所得模式的严格级别

### `.pick()`

借鉴 TypeScript 的内置工具类型 `Pick` 和 `Omit`，Zod 提供了专用 API 用于从对象模式中选择/剔除某些键。

初始模式：

```ts z.object
const Recipe = z.object({
  title: z.string(),
  description: z.string().optional(),
  ingredients: z.array(z.string()),
});
// { title: string; description?: string | undefined; ingredients: string[] }
```
选择某些键：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts zod
const JustTheTitle = Recipe.pick({ title: true });
```
</Tab>
<Tab value="Zod Mini">
```ts zod/v4-mini
const JustTheTitle = z.pick(Recipe, { title: true });
```
</Tab>
</Tabs>


### `.omit()`

剔除某些键：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts zod
const RecipeNoId = Recipe.omit({ id: true });
```
</Tab>
<Tab value="Zod Mini">
```ts zod/v4-mini
const RecipeNoId = z.omit(Recipe, { id: true });
```
</Tab>
</Tabs>


### `.partial()`

为方便起见，Zod 提供了专门 API，使部分或所有属性变为可选，灵感来自 TypeScript 内置的 [`Partial`](https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype)。

使所有字段可选：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts zod
const PartialRecipe = Recipe.partial();
// { title?: string | undefined; description?: string | undefined; ingredients?: string[] | undefined }
```
</Tab>
<Tab value="Zod Mini">
```ts zod/v4-mini
const PartialRecipe = z.partial(Recipe);
// { title?: string | undefined; description?: string | undefined; ingredients?: string[] | undefined }
```
</Tab>
</Tabs>

使指定属性可选：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts zod
const RecipeOptionalIngredients = Recipe.partial({
  ingredients: true,
});
// { title: string; description?: string | undefined; ingredients?: string[] | undefined }
```
</Tab>
<Tab value="Zod Mini">
```ts zod/v4-mini
const RecipeOptionalIngredients = z.partial(Recipe, {
  ingredients: true,
});
// { title: string; description?: string | undefined; ingredients?: string[] | undefined }
```
</Tab>
</Tabs>

### `.required()`

Zod 提供了一个使部分或所有属性*必需*的 API，灵感来自 TypeScript 内置的 [`Required`](https://www.typescriptlang.org/docs/handbook/utility-types.html#requiredtype)。

使所有属性必需：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts zod
const RequiredRecipe = Recipe.required();
// { title: string; description: string; ingredients: string[] }
```
</Tab>
<Tab value="Zod Mini">
```ts zod/v4-mini
const RequiredRecipe = z.required(Recipe);
// { title: string; description: string; ingredients: string[] }
```
</Tab>
</Tabs>

使指定属性必需：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts zod
const RecipeRequiredDescription = Recipe.required({description: true});
// { title: string; description: string; ingredients: string[] }
```
</Tab>
<Tab value="Zod Mini">
```ts zod/v4-mini
const RecipeRequiredDescription = z.required(Recipe, {description: true});
// { title: string; description: string; ingredients: string[] }
```
</Tab>
</Tabs>



## 递归对象

定义自引用类型，使用键的[getter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get)。这让 JavaScript 在运行时解析循环模式。

```ts
const Category = z.object({
  name: z.string(),
  get subcategories(){
    return z.array(Category)
  }
});

type Category = z.infer<typeof Category>;
// { name: string; subcategories: Category[] }
```

<Callout type="warn"> 
  虽支持递归模式，但传入循环数据将导致无限循环。
</Callout>

也可以表示*互相递归的类型*：

```ts
const User = z.object({
  email: z.email(),
  get posts(){
    return z.array(Post)
  }
});

const Post = z.object({
  title: z.string(),
  get author(){
    return User
  }
});
```

所有对象 API（如 `.pick()`、`.omit()`、`.required()`、`.partial()` 等）均如预期工作。

### 循环错误

由于 TypeScript 限制，递归类型推断可能出现问题，只在某些场景有效。复杂类型可能触发如下递归类型错误：

```ts
const Activity = z.object({
  name: z.string(),
  get subactivities() {
    // ^ ❌ 'subactivities' 隐式返回值类型为 'any'，因无返回类型注解且直接或间接自身引用.ts(7023)

    return z.nullable(z.array(Activity));
  },
});
```

此时，您可以在出错 getter 上加类型注解解决：

```ts
const Activity = z.object({
  name: z.string(),
  get subactivities(): z.ZodNullable<z.ZodArray<typeof Activity>> {
    return z.nullable(z.array(Activity));
  },
});
```

{/* 一些避免循环的经验法则 */}

{/* 
<Accordions>
  <Accordion title="解决递归模式中的类型错误">
    递归类型推断有一定神秘色彩。TypeScript 在部分受限场景支持此功能。根据用途，可能出现如下错误：

    ```ts
    export const Activity = z.object({
      name: z.string(),
      get children() {
        // ^ ❌ 'children' 隐式返回值类型为 'any'，因无返回类型注解且直接或间接自身引用.ts(7023)

        return z.optional(z.array(Activity)); //.optional();
      },
    });
    ```

    一些经验法则：

    ### 仅对象类型 
    
    通常递归推断只对相互引用的对象类型有效。TypeScript 对 getter 递归对象有特殊支持，Zod 依赖该特性。若加入非对象类型，可能出现错误。

    ```ts
    const Activity = z.object({
      name: z.string(),
      get children() { // ❌ 类型错误
        return z.optional(ActivityArray);
      },
    });

    const ActivityArray = z.array(Activity);
    ```

    有时通过类型定义可以绕过此限制。


    ### 避免嵌套函数调用
    
    `z.array()` 和 `z.optional()` 接受 Zod 模式，TypeScript 会对参数做类型检查，以确保有效。但类型检查与递归推断难以共存。方法（而非函数）没有该问题。因此尽可能用方法（抱歉 Zod Mini 用户）。

    ```ts
    const Activity = z.object({
      name: z.string(),
      get subactivities() {
        // ^ ❌ 'subactivities' 隐式返回值类型为 'any'，因无返回类型注解且直接或间接自身引用.ts(7023)

        return z.union([z.null(), Activity]);
      },
    });
    ```

    ### 使用类型注解
    
    有疑问时，通常在 getter 上加类型注解即可规避问题。TypeScript 限制尤其在 Zod Mini 中明显。

    ```ts
    import * as z from "zod/v4";

    const Activity = z.object({
      name: z.string(),
      get subactivities(): z.ZodMiniDefault<z.ZodMiniArray<typeof Activity>> {
        return z._default(z.array(Activity), []);
      },
    });
    ```

  </Accordion>
</Accordions> */}

## 数组

定义数组模式：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const stringArray = z.array(z.string()); // 或 z.string().array()
```
</Tab>
<Tab value="Zod Mini">
```ts zod/v4-mini
const stringArray = z.array(z.string());
```
</Tab>
</Tabs>

访问数组元素的内层模式：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
stringArray.unwrap(); // => string schema
```
</Tab>
<Tab value="Zod Mini">
```ts zod/v4-mini
stringArray.def.element; // => string schema
```
</Tab>
</Tabs>

Zod 实现了若干数组特定验证：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
z.array(z.string()).min(5); // 至少包含 5 项
z.array(z.string()).max(5); // 最多包含 5 项
z.array(z.string()).length(5); // 恰好包含 5 项
```
</Tab>
<Tab value="Zod Mini">
```ts zod/v4-mini
z.array(z.string()).check(z.minLength(5)); // 至少包含 5 项
z.array(z.string()).check(z.maxLength(5)); // 最多包含 5 项
z.array(z.string()).check(z.length(5)); // 恰好包含 5 项
```
</Tab>
</Tabs>

{/* 与 `.nonempty()` 不同，这些方法不改变推断类型。 */}

## 元组

元组通常是固定长度数组，每个索引指定不同的模式。

```ts
const MyTuple = z.tuple([
  z.string(),
  z.number(),
  z.boolean()
]);

type MyTuple = z.infer<typeof MyTuple>;
// [string, number, boolean]
```

添加可变长（"剩余"）参数：

```ts
const variadicTuple = z.tuple([z.string()], z.number());
// => [string, ...number[]];
```

## 联合类型

联合类型（`A | B`）代表逻辑“或”。Zod 联合模式依次检查输入，返回第一个验证成功的选项。

```ts
const stringOrNumber = z.union([z.string(), z.number()]);
// string | number

stringOrNumber.parse("foo"); // 通过
stringOrNumber.parse(14);    // 通过
```

访问内部选项模式：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
stringOrNumber.options; // [ZodString, ZodNumber]
```
</Tab>
<Tab value="Zod Mini">
```ts zod/v4-mini
stringOrNumber.def.options; // [ZodString, ZodNumber]
```
</Tab>
</Tabs>

{/* 方便用法：`.or` 方法：

```ts
const stringOrNumber = z.string().or(z.number());
``` */}

{/* **可选字符串验证：**

若验证可选表单输入，可将所需字符串验证与空字符串字面量联合。

例：验证可能为空或包含[有效 URL](#strings)的输入：

```ts
const optionalUrl = z.union([z.string().url().nullish(), z.literal("")]);

console.log(optionalUrl.safeParse(undefined).success); // true
console.log(optionalUrl.safeParse(null).success); // true
console.log(optionalUrl.safeParse("").success); // true
console.log(optionalUrl.safeParse("https://zod.dev").success); // true
console.log(optionalUrl.safeParse("not a valid url").success); // false
```

<br/> */}

## 带分辨字段的联合

[带分辨字段的联合](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#discriminated-unions) 是一种特殊联合，要求 a) 所有选项均为对象模式且 b) 共享特定键（“分辨字段”）。根据分辨字段的值，TypeScript 能精确缩小类型。

```ts
type MyResult =
  | { status: "success"; data: string }
  | { status: "failed"; error: string };

function handleResult(result: MyResult){
  if(result.status === "success"){
    result.data; // string
  } else {
    result.error; // string
  }
}
```

可以用常规 `z.union()` 表示。但常规联合是*朴素*的—依序测试选项，返回首个成功。大联合时可能较慢。

Zod 提供了 `z.discriminatedUnion()`，通过*分辨字段*提高解析效率。

```ts
const MyResult = z.discriminatedUnion("status", [
  z.object({ status: z.literal("success"), data: z.string() }),
  z.object({ status: z.literal("failed"), error: z.string() }),
]);
```

{/* 
<Callout>
  在 Zod 3 中，必须先指定分辨字段。Zod 4 支持自动检测，无需手动指定。

  ```ts
  const MyResult = z.discriminatedUnion("status", [
    z.object({ status: z.literal("success"), data: z.string() }),
    z.object({ status: z.literal("failed"), error: z.string() }),
  ]);
  ```

  若无法找到分辨字段，Zod 会在模式创建时抛错。
</Callout> */}

<Accordions type="single">
<Accordion title="嵌套带分辨字段的联合">

  高级用例中，分辨联合可嵌套。Zod 会确定每层最佳解析策略，利用各层分辨字段。

  ```ts
  const BaseError = { status: z.literal("failed"), message: z.string() };
  const MyErrors = z.discriminatedUnion("code", [
    z.object({ ...BaseError, code: z.literal(400) }),
    z.object({ ...BaseError, code: z.literal(401) }),
    z.object({ ...BaseError, code: z.literal(500) }),
  ]);

  const MyResult = z.discriminatedUnion("status", [
    z.object({ status: z.literal("success"), data: z.string() }),
    MyErrors
  ]);
  ```

</Accordion>
</Accordions>

## 交叉类型

交叉类型 (`A & B`) 代表逻辑“且”。

```ts
const a = z.union([z.number(), z.string()]);
const b = z.union([z.number(), z.boolean()]);
const c = z.intersection(a, b);

type c = z.infer<typeof c>; // => number
```

这对合并两个对象类型很有用。

```ts
const Person = z.object({ name: z.string() });
type Person = z.infer<typeof Person>;

const Employee = z.object({ role: z.string() });
type Employee = z.infer<typeof Employee>;

const EmployedPerson = z.intersection(Person, Employee);
type EmployedPerson = z.infer<typeof EmployedPerson>;
// Person & Employee
```

<Callout type="warn">
  大多数场景下，使用 [`A.extend(B)`](#extend) 合并对象模式更佳。此方法返回新对象模式，而 `z.intersection(A, B)` 返回的 `ZodIntersection` 实例缺少常见对象方法如 `pick` 和 `omit`。
</Callout>

## Record 类型

Record 模式用于验证如 `Record<string, number>` 类型。

```ts
const IdCache = z.record(z.string(), z.string());
type IdCache = z.infer<typeof IdCache>; // Record<string, string>

IdCache.parse({
  carlotta: "77d2586b-9e8e-4ecf-8b21-ea7e0530eadd",
  jimmie: "77d2586b-9e8e-4ecf-8b21-ea7e0530eadd",
});
```

键模式可为任何可赋值给 `string | number | symbol` 的 Zod 模式。

```ts
const Keys = z.union([z.string(), z.number(), z.symbol()]);
const AnyObject = z.record(Keys, z.unknown());
// Record<string | number | symbol, unknown>
```

使用枚举定义键的对象模式：

```ts
const Keys = z.enum(["id", "name", "email"]);
const Person = z.record(Keys, z.string());
// { id: string; name: string; email: string }
```

<Callout>
  **Zod 4** — 在 Zod 4 中，若将 `z.enum` 传给 `z.record()` 作为第一个参数，Zod 会详尽检查输入对象是否包含所有枚举值作为键。此行为与 TypeScript 保持一致：

  ```ts
  type MyRecord = Record<"a" | "b", string>;
  const myRecord: MyRecord = { a: "foo", b: "bar" }; // ✅
  const myRecord: MyRecord = { a: "foo" }; // ❌ 缺少必需键 `b`
  ```

  在 Zod 3 中，没有检查穷尽性。要复制旧的行为，请使用 `z.partialRecord()`。

</Callout>

若需定义*部分* Record 类型，使用 `z.partialRecord()` 。此方法跳过 Zod 对 `z.enum()` 和 `z.literal()` 键模式的详尽检查。

```ts
const Keys = z.enum(["id", "name", "email"]).or(z.never()); 
const Person = z.partialRecord(Keys, z.string());
// { id?: string; name?: string; email?: string }
```

<Accordions>
<Accordion title="关于数字键的说明">

尽管 TypeScript 允许定义 `Record<number, unknown>` 等数字键的 Record 类型，JavaScript 中数字键实际上不存在，都会转换为字符串。

```ts
const myObject = { 1: "one" };

Object.keys(myObject); 
// => ["1"]
```

如上所示，JS 会将所有数字键自动转换为字符串。因此，在 `z.record()` 中使用 `z.number()` 作为键模式，解析时会抛错，但 Zod 为保持与 TypeScript 的一致性，仍允许此用法。

</Accordion></Accordions>

## Map 类型

```ts
const StringNumberMap = z.map(z.string(), z.number());
type StringNumberMap = z.infer<typeof StringNumberMap>; // Map<string, number>

const myMap: StringNumberMap = new Map();
myMap.set("one", 1);
myMap.set("two", 2);

StringNumberMap.parse(myMap);
```

## Set 类型

```ts
const NumberSet = z.set(z.number());
type NumberSet = z.infer<typeof NumberSet>; // Set<number>

const mySet: NumberSet = new Set();
mySet.add(1);
mySet.add(2);
NumberSet.parse(mySet);
```

Set 模式可用以下方法进一步约束。

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
z.set(z.string()).min(5); // 至少 5 个元素
z.set(z.string()).max(5); // 最多 5 个元素
z.set(z.string()).size(5); // 恰好 5 个元素
```
</Tab>
<Tab value='zod/v4-mini'>
```ts
z.set(z.string()).check(z.minSize(5)); // 至少 5 个元素
z.set(z.string()).check(z.maxSize(5)); // 最多 5 个元素
z.set(z.string()).check(z.size(5)); // 恰好 5 个元素
```
</Tab>
</Tabs>

## 文件

验证 `File` 实例：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const fileSchema = z.file();

fileSchema.min(10_000); // 最小 .size（字节）
fileSchema.max(1_000_000); // 最大 .size（字节）
fileSchema.mime(["image/png"]); // MIME 类型
```

</Tab>
<Tab value='zod/v4-mini'>
```ts
const fileSchema = z.file();

fileSchema.check(
  z.minSize(10_000), // 最小 .size（字节）
  z.maxSize(1_000_000), // 最大 .size（字节）
  z.mime(["image/png"]); // MIME 类型
)
```
</Tab>
</Tabs>

## Promise

<Callout type="warn">
  **已弃用** — `z.promise()` 在 Zod 4 中已弃用。有效的使用场景极少。若怀疑值是 `Promise`，应在 Zod 验证前先 `await`。
</Callout>

<Accordions type="single"><Accordion title="查看 z.promise() 文档">

```ts
const numberPromise = z.promise(z.number());
```

解析 Promise 的方式稍有不同。验证分两步：

1. 同步检查输入是否为 Promise 实例（即含 `.then` 和 `.catch` 方法的对象）。
2. 利用 `.then` 给 Promise 附加额外验证。需用 `.catch` 处理验证失败。

```ts
numberPromise.parse("tuna");
// ZodError: 非 Promise 类型：string

numberPromise.parse(Promise.resolve("tuna"));
// => Promise<number>

const test = async () => {
  await numberPromise.parse(Promise.resolve("tuna"));
  // ZodError: 非数字类型：string

  await numberPromise.parse(Promise.resolve(3.14));
  // => 3.14
};
```

</Accordion></Accordions>

## instanceof 验证

使用 `z.instanceof` 验证输入是否为指定类的实例。适合验证来自第三方库的类实例。

```ts
class Test {
  name: string;
}

const TestSchema = z.instanceof(Test);

TestSchema.parse(new Test()); // ✅
TestSchema.parse("whatever"); // ❌
```

## 精炼验证

每个 Zod 模式都存有一组*精炼*数组。精炼用于执行 Zod 本身无内置 API 的自定义验证。

### `.refine()`

{/* <Callout>
  检查事实上不会且不能改变模式的推断类型。
</Callout>

### `.refine()` */}

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const myString = z.string().refine((val) => val.length <= 255);
```
</Tab>
<Tab value="Zod Mini">
```ts zod/v4-mini
const myString = z.string().check(z.refine((val) => val.length <= 255));
```
</Tab>
</Tabs>

<Callout type="warn">
  精炼函数不应抛异常，且应返回假值表示失败。抛出错误不被 Zod 捕获。
</Callout>

自定义错误消息：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const myString = z.string().refine((val) => val.length > 8, { 
  error: "Too short!" 
});
```
</Tab>
<Tab value="Zod Mini">
```ts zod/v4-mini
const myString = z.string().check(
  z.refine((val) => val.length > 8, { error: "Too short!" })
);
```
</Tab>
</Tabs>


默认情况下，验证问题视为*可继续*，即所有检查都会依次执行，即便前面发生错误。此行为通常有利，可一次发现尽可能多错误。

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const myString = z.string()
  .refine((val) => val.length > 8, { error: "Too short!" })
  .refine((val) => val === val.toLowerCase(), { error: "Must be lowercase" });
  

const result = myString.safeParse("OH NO");
result.error.issues;
/* [
  { "code": "custom", "message": "Too short!" },
  { "code": "custom", "message": "Must be lowercase" }
] */
```
</Tab>
<Tab value="Zod Mini">
```ts zod/v4-mini
const myString = z.string().check(
  z.refine((val) => val.length > 8, { error: "Too short!" }),
  z.refine((val) => val === val.toLowerCase(), { error: "Must be lowercase" })
);

const result = z.safeParse(myString, "OH NO");
result.error.issues;
/* [
  { "code": "custom", "message": "Too short!" },
  { "code": "custom", "message": "Must be lowercase" }
] */
```
</Tab>
</Tabs>

使精炼为*不可继续*，失败时立即终止：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const myString = z.string()
  .refine((val) => val.length > 8, { error: "Too short!", abort: true })
  .refine((val) => val === val.toLowerCase(), { error: "Must be lowercase", abort: true });


const result = myString.safeParse("OH NO");
result.error!.issues;
// => [{ "code": "custom", "message": "Too short!" }]
```
</Tab>
<Tab value="Zod Mini">
```ts zod/v4-mini
const myString = z.string().check(
  z.refine((val) => val.length > 8, { error: "Too short!", abort: true }),
  z.refine((val) => val === val.toLowerCase(), { error: "Must be lowercase", abort: true })
);

const result = z.safeParse(myString, "OH NO");
result.error!.issues;
// [ { "code": "custom", "message": "Too short!" }]
```
</Tab>
</Tabs>

自定义错误路径，通常只在对象模式中有用：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const passwordForm = z
  .object({
    password: z.string(),
    confirm: z.string(),
  })
  .refine((data) => data.password === data.confirm, {
    message: "Passwords don't match",
    path: ["confirm"], // 错误路径
  });
```
</Tab>
<Tab value="Zod Mini">
```ts
const passwordForm = z
  .object({
    password: z.string(),
    confirm: z.string(),
  })
  .check(z.refine((data) => data.password === data.confirm, {
    message: "Passwords don't match",
    path: ["confirm"], // 错误路径
  }));
```
</Tab>
</Tabs>

这会将 `path` 设置为相关问题：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const result = passwordForm.safeParse({ password: "asdf", confirm: "qwer" });
result.error.issues;
/* [{
  "code": "custom",
  "path": [ "confirm" ],
  "message": "Passwords don't match"
}] */
```
</Tab>
<Tab value="Zod Mini">
```ts
const result = z.safeParse(passwordForm, { password: "asdf", confirm: "qwer" });
result.error.issues;
/* [{
  "code": "custom",
  "path": [ "confirm" ],
  "message": "Passwords don't match"
}] */
```
</Tab>
</Tabs>

精炼可以是 `async`：

```ts
const userId = z.string().refine(async (id) => {
  // 验证 ID 是否存在数据库
  return true;
});
```

<Callout>
  若使用异步精炼，解析数据时必须调用 `.parseAsync` ，否则 Zod 会抛错。

  <Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
  <Tab value="Zod">
  ```ts
  const result = await userId.parseAsync("abc123");
  ```
  </Tab>
  <Tab value="Zod Mini">
  ```ts
  const result = await z.parseAsync(userId, "abc123");
  ```
  </Tab>
  </Tabs>
</Callout>

### `.superRefine()`

<Callout type="warn">
  在 Zod 4 中，`.superRefine()` 已被弃用，建议用 `.check()` 代替。
  
  <Accordions>
  <Accordion title="查看 .superRefine() 示例">
    
    <Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
    <Tab value="Zod">
    ```ts
    const UniqueStringArray = z.array(z.string()).superRefine((val, ctx) => {
      if (val.length > 3) {
        ctx.addIssue({
          code: "too_big",
          maximum: 3,
          origin: "array",
          inclusive: true,
          message: "Too many items 😡",
          input: val,
        });
      }

      if (val.length !== new Set(val).size) {
        ctx.addIssue({
          code: "custom",
          message: `No duplicates allowed.`,
          input: val,
        });
      }
    });
    ```
    </Tab>
    <Tab value="Zod Mini">
    ```ts
    // 无对应功能，使用 `z.check()` 替代
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
    ```
    </Tab>
    </Tabs>
  </Accordion>
  </Accordions>
</Callout>

### `.check()`


`.refine()` 是 `.check()` 的语法糖，后者更灵活（但更啰嗦）。您可以用它在单个精炼中产生多个问题，或完全控制问题对象。

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const UniqueStringArray = z.array(z.string()).check((ctx) => {
  if (ctx.value.length > 3) {
    ctx.issues.push({
      code: "too_big",
      maximum: 3,
      origin: "array",
      inclusive: true,
      message: "Too many items 😡",
      input: ctx.value
    });
  }

  if (ctx.value.length !== new Set(ctx.value).size) {
    ctx.issues.push({
      code: "custom",
      message: `No duplicates allowed.`,
      input: ctx.value,
      continue: true // 使此问题可继续（默认：false）
    });
  }
});
```
</Tab>
<Tab value="Zod Mini">
```ts
const UniqueStringArray = z.array(z.string()).check((ctx) => {
  if (ctx.value.length > 3) {
    ctx.issues.push({
      code: "too_big",
      maximum: 3,
      origin: "array",
      inclusive: true,
      message: "Too many items 😡",
      input: ctx.value
    });
  }

  if (ctx.value.length !== new Set(ctx.value).size) {
    ctx.issues.push({
      code: "custom",
      message: `No duplicates allowed.`,
      input: ctx.value,
      continue: true // 使此问题可继续（默认：false）
    });
  }
});
```
</Tab>
</Tabs>

常规 `.refine` 仅生成 `"custom"` 错误代码的问题，但 `.check()` 可以抛出其他问题类型。详情请参阅 [错误定制](./error-customization) 文档。

## 管道（Pipes）

模式可串联成“管道”。管道主要在搭配[变换](#transforms)时有用。

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const stringToLength = z.string().pipe(z.transform(val => val.length));

stringToLength.parse("hello"); // => 5
```
</Tab>
<Tab value="Zod Mini">
```ts
const stringToLength = z.pipe(z.string(), z.transform(val => val.length));

z.parse(stringToLength, "hello"); // => 5
```
</Tab>
</Tabs>


## 变换（Transforms）

变换是一种特殊模式。它们不验证输入，而是接受任何数据并执行转换。定义变换：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const castToString = z.transform((val) => String(val));

castToString.parse("asdf"); // => "asdf"
castToString.parse(123); // => "123"
castToString.parse(true); // => "true"
```
</Tab>
<Tab value="Zod Mini">
```ts zod/v4-mini
const castToString = z.transform((val) => String(val));

z.parse(castToString, "asdf"); // => "asdf"
z.parse(castToString, 123); // => "123"
z.parse(castToString, true); // => "true"
```
</Tab>
</Tabs>

{/* 变换模式的输出类型由变换函数推断：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const castToString = z.transform((val) => String(val));

type CastToString = z.infer<typeof castToString>; // string
```
</Tab>
<Tab value="Zod Mini">
```ts zod/v4-mini
const castToString = z.transform((val) => String(val));

type CastToString = z.infer<typeof castToString>; // string
```
</Tab>
</Tabs> */}


在变换中执行验证逻辑，使用 `ctx`。添加验证问题，推入 `ctx.issues`（类似[`.check()`](#check) API）。

```ts
const coercedInt = z.transform((val, ctx) => {
  try {
    const parsed = Number.parseInt(String(val));
    return parsed;
  } catch (e) {
    ctx.issues.push({
      code: "custom",
      message: "Not a number",
      input: val,
    });

    // 这是类型为 `never` 的特殊常量
    // 返回它可退出变换且不影响推断返回类型
    return z.NEVER;
  }
});
```

变换通常与[管道](#pipes)联合使用。此组合方便在执行初步验证后，将解析数据转换为另一形式。

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const stringToLength = z.string().pipe(z.transform(val => val.length));

stringToLength.parse("hello"); // => 5
```
</Tab>
<Tab value="Zod Mini">
```ts
const stringToLength = z.pipe(z.string(), z.transform(val => val.length));

z.parse(stringToLength, "hello"); // => 5
```
</Tab>
</Tabs>

### `.transform()`

将管道输入转换，常用模式，Zod 提供 `.transform()` 便捷方法。

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const stringToLength = z.string().transform(val => val.length); 
```
</Tab>
<Tab value="Zod Mini">
```ts
// 无对应功能
```
</Tab>
</Tabs>

变换可异步：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const idToUser = z
  .string()
  .transform(async (id) => {
    // 从数据库获取用户
    return db.getUserById(id); 
  });

const user = await idToUser.parseAsync("abc123");
```
</Tab>
<Tab value="Zod Mini">
```ts
const idToUser = z.pipe(
  z.string(),
  z.transform(async (id) => {
    // 从数据库获取用户
    return db.getUserById(id); 
  }));

const user = await idToUser.parse("abc123");
```
</Tab>
</Tabs>

<Callout>
  若使用异步变换，解析数据时必须用 `.parseAsync` 或 `.safeParseAsync`，否则 Zod 会抛错。
</Callout>

### `.preprocess()` 

将变换管道至另一个模式也常见，Zod 提供 `z.preprocess()` 便捷函数。

```ts
const coercedInt = z.preprocess((val) => {
  if (typeof val === "string") {
    return Number.parseInt(val);
  }
  return val;
}, z.int());
```

## 默认值

为模式设置默认值：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const defaultTuna = z.string().default("tuna");

defaultTuna.parse(undefined); // => "tuna"
```
</Tab>
<Tab value="Zod Mini">
```ts
const defaultTuna = z._default(z.string(), "tuna");

defaultTuna.parse(undefined); // => "tuna"
```
</Tab>
</Tabs>

也可传入函数，每次需生成默认值时执行：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const randomDefault = z.number().default(Math.random);

randomDefault.parse(undefined);    // => 0.4413456736055323
randomDefault.parse(undefined);    // => 0.1871840107401901
randomDefault.parse(undefined);    // => 0.7223408162401552
```
</Tab>
<Tab value="Zod Mini">
```ts
const randomDefault = z._default(z.number(), Math.random);

z.parse(randomDefault, undefined); // => 0.4413456736055323
z.parse(randomDefault, undefined); // => 0.1871840107401901
z.parse(randomDefault, undefined); // => 0.7223408162401552
```
</Tab>
</Tabs>


## 预故障值（Prefaults）

在 Zod 中，设置*默认值*会短路解析。若输入为 `undefined`，会立即返回默认值。因此默认值必须赋值给模式的*输出类型*。

```ts
const schema = z.string().transform(val => val.length).default(0);
schema.parse(undefined); // => 0
```

有时定义*预故障值*（“预解析默认”）更实用。若输入为 `undefined`，将替代性地先解析预故障值，解析过程*不*短路。因此，预故障值必须赋值给模式的*输入类型*。

```ts
z.string().transform(val => val.length).prefault("tuna");
schema.parse(undefined); // => 4
```

若希望在一些变异型精炼中使用输入值，此法有用。

```ts
const a = z.string().trim().toUpperCase().prefault("  tuna  ");
a.parse(undefined); // => "TUNA"

const b = z.string().trim().toUpperCase().default("  tuna  ");
b.parse(undefined); // => "  tuna  "
```

## 捕获值（Catch）

使用 `.catch()` 定义验证错误时的备用值：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const numberWithCatch = z.number().catch(42);

numberWithCatch.parse(5); // => 5
numberWithCatch.parse("tuna"); // => 42
```
</Tab>
<Tab value="Zod Mini">
```ts
const numberWithCatch = z.catch(z.number(), 42);

numberWithCatch.parse(5); // => 5
numberWithCatch.parse("tuna"); // => 42
```
</Tab>
</Tabs>


或传入函数，每次生成捕获值时执行:

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const numberWithRandomCatch = z.number().catch((ctx) => {
  ctx.error; // 捕获的 ZodError
  return Math.random();
});

numberWithRandomCatch.parse("sup"); // => 0.4413456736055323
numberWithRandomCatch.parse("sup"); // => 0.1871840107401901
numberWithRandomCatch.parse("sup"); // => 0.7223408162401552
```
</Tab>
<Tab value="Zod Mini">
```ts
const numberWithRandomCatch = z.catch(z.number(), (ctx) => {
  ctx.value;   // 输入值
  ctx.issues;  // 捕获的验证问题
  return Math.random();
});

z.parse(numberWithRandomCatch, "sup"); // => 0.4413456736055323
z.parse(numberWithRandomCatch, "sup"); // => 0.1871840107401901
z.parse(numberWithRandomCatch, "sup"); // => 0.7223408162401552
```
</Tab>
</Tabs>

## 品牌类型

TypeScript 类型系统是[结构化](https://www.typescriptlang.org/docs/handbook/type-compatibility.html)的，结构相同的类型被视为相同。

```ts
type Cat = { name: string };
type Dog = { name: string };

const pluto: Dog = { name: "pluto" };
const simba: Cat = pluto; // works fine
```

某些情况中，想在 TypeScript 内模拟[标称类型](https://en.wikipedia.org/wiki/Nominal_type_system)，可用*品牌类型*（又称“不透明类型”）。

```ts
const Cat = z.object({ name: z.string() }).brand<"Cat">();
const Dog = z.object({ name: z.string() }).brand<"Dog">();

type Cat = z.infer<typeof Cat>; // { name: string } & z.$brand<"Cat">
type Dog = z.infer<typeof Dog>; // { name: string } & z.$brand<"Dog">

const pluto = Dog.parse({ name: "pluto" });
const simba: Cat = pluto; // ❌ 不允许
```

其原理是为模式推断类型附加“品牌”。

```ts
const Cat = z.object({ name: z.string() }).brand<"Cat">();
type Cat = z.infer<typeof Cat>; // { name: string } & z.$brand<"Cat">
```

带品牌后，普通（无品牌）数据结构不再可赋值给推断类型。需解析获得品牌数据。


> 注意，品牌类型不会影响 `.parse` 的运行时结果，只是静态构造。

## 只读

使模式只读：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const ReadonlyUser = z.object({ name: z.string() }).readonly();
type ReadonlyUser = z.infer<typeof ReadonlyUser>;
// Readonly<{ name: string }>
```
</Tab>
<Tab value="Zod Mini">
```ts
const ReadonlyUser = z.readonly(z.object({ name: z.string() }));
type ReadonlyUser = z.infer<typeof ReadonlyUser>;
// Readonly<{ name: string }>
```
</Tab>
</Tabs>

新模式推断类型会标记为 `readonly`。注意，在 TypeScript 中，这只影响对象、数组、元组、`Set` 和 `Map`：

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
z.object({ name: z.string() }).readonly(); // { readonly name: string }
z.array(z.string()).readonly(); // readonly string[]
z.tuple([z.string(), z.number()]).readonly(); // readonly [string, number]
z.map(z.string(), z.date()).readonly(); // ReadonlyMap<string, Date>
z.set(z.string()).readonly(); // ReadonlySet<string>
```
</Tab>
<Tab value="Zod Mini">
```ts
z.readonly(z.object({ name: z.string() })); // { readonly name: string }
z.readonly(z.array(z.string())); // readonly string[]
z.readonly(z.tuple([z.string(), z.number()])); // readonly [string, number]
z.readonly(z.map(z.string(), z.date())); // ReadonlyMap<string, Date>
z.readonly(z.set(z.string())); // ReadonlySet<string>
```
</Tab>
</Tabs>

输入会像往常一样被解析，结果使用 [`Object.freeze()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze) 冻结，防止修改。

<Tabs groupId="lib" items={["Zod", "Zod Mini"]}>
<Tab value="Zod">
```ts
const result = ReadonlyUser.parse({ name: "fido" });
result.name = "simba"; // 抛出 TypeError
```
</Tab>
<Tab value="Zod Mini">
```ts
const result = z.parse(ReadonlyUser, { name: "fido" });
result.name = "simba"; // 抛出 TypeError
```
</Tab>
</Tabs>

## JSON

验证任意 JSON 可编码值：

```ts
const jsonSchema = z.json();
```

此为便捷 API，返回如下联合模式：

```ts
const jsonSchema = z.lazy(() => {
  return z.union([
    z.string(params), 
    z.number(), 
    z.boolean(), 
    z.null(), 
    z.array(jsonSchema), 
    z.record(z.string(), jsonSchema)
  ]);
});
```


## 自定义

使用 `z.custom()` 创建任何 TypeScript 类型的 Zod 模式。适合创建 Zod 不支持的类型模式，如模板字符串字面量。

```ts
const px = z.custom<`${number}px`>((val) => {
  return typeof val === "string" ? /^\d+px$/.test(val) : false;
});

type px = z.infer<typeof px>; // `${number}px`

px.parse("42px"); // "42px"
px.parse("42vw"); // 抛错
```

若不提供验证函数，Zod 将允许任何值。这可能不安全！

```ts
z.custom<{ arg: string }>(); // 不执行任何验证
```

可通过第二参数定制错误消息及其它选项，与[`.refine`](#refine)的参数用法相同。

```ts
z.custom<...>((val) => ..., "custom error message");
```

## 函数

<Callout type="warn">
  Zod 4 中，`z.function()` 不再返回 Zod 模式。
</Callout>

Zod 提供 `z.function()` 工具定义经过 Zod 验证的函数。避免验证码混入业务逻辑。

```ts
const MyFunction = z.function({
  input: [z.string()], // 参数（必须为数组或 ZodTuple）
  output: z.number()  // 返回值类型
});
```

函数模式拥有 `.implement()` 方法，接受函数，返回自动验证输入输出的新函数。

```ts
const computeTrimmedLength = MyFunction.implement((input) => {
  // TypeScript 识别 input 为 string！
  return input.trim().length;
});

computeTrimmedLength("sandwich"); // => 8
computeTrimmedLength(" asdf "); // => 4
```

输入验证失败时抛 `ZodError`：

```ts
computeTrimmedLength(42); // 抛出 ZodError
```

若只关心验证输入，可省略 `output` 字段。

```ts
const MyFunction = z.function({
  input: [z.string()], // 参数（必须是数组或 ZodTuple）
});

const computeTrimmedLength = MyFunction.implement((input) => input.trim.length);
```
